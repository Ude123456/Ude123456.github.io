<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红黑树</title>
      <link href="/2022/11/12/hong-hei-shu/"/>
      <url>/2022/11/12/hong-hei-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径(Dijkstra算法)</title>
      <link href="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/"/>
      <url>/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Dijkstra算法刚接触时确实有点难以理解，尤其是代码的实现，但其背后的逻辑实际上是用贪心算法来支撑的。但是在算法学习中Dijkstra算法又是最基本的一种算法，对于求解单源最短路径有着极大的作用。在这里我简单讲一下自己的理解，我的代码参考了《图解数据结构》，该代码适合稠密图，使用的是邻接矩阵来存储的图。 </p></blockquote><hr><h2 id="1、Dijkstra算法主要步骤"><a href="#1、Dijkstra算法主要步骤" class="headerlink" title="1、Dijkstra算法主要步骤"></a>1、Dijkstra算法主要步骤</h2><p><img src="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4.png"></p><p>对于贪心算法，简单描述一下：<br>贪心算法正如其名字一样，贪心算法只注重眼前利益，就像贪心的小人一样，因此得名贪心算法，该算法即从一个初始解，一步步选取当前最优解，最终得出近似的最优解（注意：不一定是该问题的最优解，而是近似于最优解）。<br>实现该算法的基本过程如下。<br>（1）从问题的某一初始解出发。<br>（2）while能向给定总目标前进一步。<br>（3）求出可行解的一个解元素。<br>（4）由所有解元素组合成问题的一个可行解。<br>（想更深入了解请参考链接<a href="https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187%EF%BC%89">https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187）</a></p><hr><h2 id="2、Dijkstra算法小结"><a href="#2、Dijkstra算法小结" class="headerlink" title="2、Dijkstra算法小结"></a>2、Dijkstra算法小结</h2><p> 1、Dijkstra算法一般是用来解决单源最短路径问题（指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。）<br> 2、其时间复杂度仅为O(n^2^)，并且非常高效，甚至可以优化成O(log2n)。<br> 3、Dijkstra算法中权值只能为正数，若权值为负数则不能使用该算法。（权值即图各个边所赋予的值）  </p><hr><h2 id="3、算法实现"><a href="#3、算法实现" class="headerlink" title="3、算法实现"></a>3、算法实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; #define SIZE 7#define NUMBER 6#define INFINITE 123456  &#x2F;&#x2F;宏定义无穷大 &#x2F;&#x2F;首先定义图的数组int Graph_Matrix[SIZE][SIZE];int Distance[SIZE];  &#x2F;&#x2F;路径长度 &#x2F;&#x2F;建立有向图void Create_Graph(int *Path_Cost)&#123;    int i,j;    for(i&#x3D;0;i&lt;SIZE;i++)    &#123;        for(j&#x3D;0;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;若是在对角线上，设置元素值为0            if(i&#x3D;&#x3D;j)            &#123;                Graph_Matrix[i][j]&#x3D;0;            &#125;            &#x2F;&#x2F;其他位置元素的值为无穷大            else            &#123;                Graph_Matrix[i][j]&#x3D;INFINITE;            &#125;        &#125;    &#125;     int End_Point,Start_Point;  &#x2F;&#x2F;图的边起始位置和终止位置     &#x2F;&#x2F;存入图的各个数据：边，权重    i&#x3D;0;    while(i&lt;SIZE)    &#123;        Start_Point&#x3D;Path_Cost[i*3];  &#x2F;&#x2F;在邻接矩阵中的行        End_Point&#x3D;Path_Cost[i*3+1];  &#x2F;&#x2F;在邻接矩阵中的列        &#x2F;&#x2F;图各边权值转化为邻接矩阵中所在的位置        Graph_Matrix[Start_Point][End_Point]&#x3D;Path_Cost[i*3+2];        i++;    &#125;&#125; &#x2F;&#x2F;打印邻接矩阵void Print_Matrix()&#123;    int i&#x3D;0,j&#x3D;0;    for(i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;vex&quot; &lt;&lt; i ;        for(j&#x3D;1;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;为了美观和可读性，将值为无穷大的元素打印为x            if(Graph_Matrix[i][j]&#x3D;&#x3D;INFINITE)            &#123;                cout &lt;&lt; setw(5) &lt;&lt; &quot;x&quot;;            &#125;            else            &#123;                cout &lt;&lt; setw(5) &lt;&lt; Graph_Matrix[i][j];            &#125;        &#125;        cout &lt;&lt; endl;    &#125;&#125; &#x2F;&#x2F;开始求解单源最短路径void Shortest_Path(int vertex1,int vertex_total)&#123;    int Shortest_vertex&#x3D;1;  &#x2F;&#x2F;初始化    int Shortest_distance;  &#x2F;&#x2F;最短距离    int flag[SIZE];  &#x2F;&#x2F;标志数组，标志顶点是否已经遍历过    int i,j;     for(i&#x3D;1;i&lt;&#x3D;vertex_total;i++)    &#123;        flag[i]&#x3D;0;  &#x2F;&#x2F;初始化标志数组        Distance[i]&#x3D;Graph_Matrix[vertex1][i];  &#x2F;&#x2F;将图的权值存入Distance[]数组中    &#125;     flag[vertex1]&#x3D;1;  &#x2F;&#x2F;标志该顶点已经找过    Distance[vertex1]&#x3D;0;  &#x2F;&#x2F;顶点到该顶点自身的距离为0     for(i&#x3D;0;i&lt;&#x3D;vertex_total-1;i++)    &#123;        Shortest_distance&#x3D;INFINITE;        for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;找到最小权边的顶点            if(flag[j]&#x3D;&#x3D;0 &amp;&amp; Distance[j]&lt;&#x3D;Shortest_distance)            &#123;                Shortest_distance&#x3D;Distance[j];                Shortest_vertex&#x3D;j;            &#125;        &#125;         flag[Shortest_vertex]&#x3D;1;  &#x2F;&#x2F;找到下一个顶点后标记为已经经过         for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;以上一个顶点为父节点，若前一个顶点和下一个权边的和最小，则更新最短路径            if(flag[j]&#x3D;&#x3D;0 &amp;&amp;               Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j]               &lt;Distance[j])            &#123;                &#x2F;&#x2F;更新最短路径                Distance[j]&#x3D;Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j];            &#125;        &#125;    &#125;&#125; int main()&#123;    int Path_Cost[9][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;1,3,5&#125;,&#123;1,4,1&#125;,&#123;1,5,3&#125;,&#123;1,6,4&#125;,                         &#123;2,5,3&#125;,&#123;4,5,7&#125;,&#123;4,6,6&#125;,&#123;4,3,2&#125;&#125;;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;此范例图的邻接矩阵如下：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;顶点   vex1 vex2 vex3 vex4 vex5 vex6&quot; &lt;&lt; endl;    Create_Graph(&amp;Path_Cost[0][0]);    Print_Matrix();    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;顶点1到各顶点最短距离的最终结果&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    &#x2F;&#x2F;查找最短路径    Shortest_Path(1,NUMBER);    for(int i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;顶点1&quot; &lt;&lt; &quot;到顶点&quot; &lt;&lt; i &lt;&lt; &quot;的最短距离&#x3D;&quot; &lt;&lt; Distance[i] &lt;&lt; endl;    &#125;     system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树(Kruskal算法)</title>
      <link href="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/"/>
      <url>/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一下子就接触算法原理和一堆七七八八的术语概念，无疑是让人头疼的，因为无端出现这么多的信息，都不知道它的来历，又不知道这些信息到底有什么用，所以我们就从最简单的内容开始，将这个算法完整地梳理一下吧。</p></blockquote><hr><h2 id="1、知识脉络梳理"><a href="#1、知识脉络梳理" class="headerlink" title="1、知识脉络梳理"></a>1、知识脉络梳理</h2><h3 id="1、树形结构"><a href="#1、树形结构" class="headerlink" title="1、树形结构"></a>1、树形结构</h3><p>首先，先来看看一个简单的数据结构——树。<br>树形结构，从字面上来理解，就是像我们生活中常见的树长的很类似。在数据结构中我们无非就是将生活中的树倒过来看而已，也就是树根在上，树叶在下。这么设计其实也没什么特别的道理，只是在遍历树的时候，我们从树根开始，从树根往叶子节点出发。但是除了倒着放，其实我们也可以将他伸展开来放，例如下面的这棵树，其实也是一棵树</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE1.png"></p><p>我们大致的想象一下，就像直接抓着树根将它拎起来，那么就自然变成了上图的样子了。</p><p>于是我们就发现，不管拎起是哪个节点，都会得到一棵树。也就是说，如果树根的位置对我们不再重要的话，树其实就等价于上面这样的图。</p><p>那么这样的图究竟是什么图呢？它有什么性质呢？所有的图都能看成是树吗？下面我们来看一下三种情况：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE2.png"></p><p>显然这三种情况<strong>都不是树</strong>。第一种是因为图中的边有方向了，一旦有了方向，图中连通的情况就被破坏了。我们都知道，树应该是全部连通的，也就是说你从任意一个节点开始，都可以走到树上任何位置。那么根据定义，<strong>不能全连通，肯定就不是树</strong>。情况2也不对，因为<strong>有了环</strong>，树是不应该有环的，大家应该没见过那种从树根还能再到树根的树吧，那不是成了老树精了？在我们定义中的树也是<strong>不能有环</strong>的，不然我们遍历的时候不是永远也找不到终点了吗？第三种情况则是因为有个别的点孤立在外，因此<strong>不能连通</strong>，所以也不是树。</p><p>所以总结一下，树就是可以全连通的（无向图），并且没有环的图。</p><h3 id="2、从图到树"><a href="#2、从图到树" class="headerlink" title="2、从图到树"></a>2、从图到树</h3><p>从上面的部分，其实我们可以发现，<strong>树的本质就是图</strong>，无非就是一些具有特殊性质的图。因此我们也经常能看到许多有关于树的算法会被纳入图论当中。</p><p>通过对树的观察，其实我们可以发现一条重要性质，对于一棵拥有n个节点的树而言，它会有n-1条边。因此如果超过n-1条边，证明当中一定存在环路，如果不理解的话，你可以简单画个图尝试一下。反之，如果小于n-1条边，那么一定存在不连通的部分。但我们需要注意，这个性质正向可以成立，反过来就不成立了，用数学中的概念来说就是，它是一个必要条件，但不是一个充分条件。也就是说并不是n个点和n-1条边就一定是树，这个画个图就很容易得出反例。</p><p>接下来我们就用这个性质来尝试解决一下由图转化成树的问题。</p><p>现在有一个稍微复杂的图，如下图：<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE3.png"><br>那么我们现在就根据这一个图生成一棵能够连通所有节点的树。根据上述的性质，我们的方法很明确，无非就是两种办法：</p><p>第一种办法是删边，既然是一个复杂图，说明边的数量肯定要超过n-1的，所以我们可以尝试去删减掉一些边，最后留下一棵树就可以了。</p><p>第二种做法则是增边，也就是说我们从零开始，一开始先把所有的边全部撤掉，然后一条一条地往一个集合当中添加n-1条边，让它变成一棵树。</p><p>那这两种方法哪种更好呢？我们可以想一下，我们每一次在删除边的时候是不是都需要考虑到<strong>是否会破坏树的连通关系</strong>，因此添加边的做法明显优于删减边的做法。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE4.png"></p><p>可以看看上图，如果我们删除AB这条边，就会发现这个已经不是连通图了，那必然也不可能成为一棵树。要判断连通关系，最好的方法就是先删除这条边，然后试着从A点出发，看看能否到达B点，如果能到达，则认为这条边是可以删除的，但是如果这么做的话，一旦图很大时，<strong>每一次删除需要遍历整张图</strong>，那么效率就会很低。并且每一次删除后，由于图的结构会发生 变化，我们还需要对这些变化进行存储，但由于他是一直动态变化，存储这些结果十分困难。</p><p>因此，删除边的方式可行，但是十分麻烦。</p><p>至此，我们知道了其实所谓的最小生成树就是从一个图当中选取n-1条边将他变换为一棵树的算法</p><h3 id="3、生成树"><a href="#3、生成树" class="headerlink" title="3、生成树"></a>3、生成树</h3><p>我们暂且不考虑带权问题，就先假设所有的边都是等权重的。</p><p>那么现在我们知道要采用添加边的方式，那我们选择一条边时，应该怎么判断这条有没有必要添加到集合中去呢？</p><p>树有一条性质是，树上任意的两个点，它们之间的路径有且只有一条，如果存在两点之间的路径有两条，那么必然可以形成一个环。那么我们就可以知道如果当前两个点之间已经存在通路的时候，就证明那么当前这两个点连成的边就不能再添加了，否则一定会出现环。因此我们需要设计的算法要<strong>维护树上点的连通性</strong>。</p><p>但是这又会有一个新问题，我们知道，在树结构当中，<strong>连通性是可以传递的</strong>。如果两个点之间连了一条边，并不仅仅只是这两个点连通，还包括了所有与这两个点之间连通的点都连通了。下面来看一个例子：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE5.png"></p><p>这张图当中A和B连了一条边，这不仅仅是A和B连通，而是<strong>左半边的集合和右半边集合的连通</strong>。所以，虽然A只是和B连通了，但是和C也连通了。AC这条边也一样不能被加入了。也就是说A和B连通，其实是<strong>A所在的集合和B所在的集合合并</strong>的过程。看到集合的合并我们就可以想到并查集，并查集算法就是用来解决集合合并和查询问题的。那么，显然可以用并查集来维护图中这些点集的连通性。关于并查集，如果不知道的朋友可以点击一下<a href="https://blog.csdn.net/bjweimengshu/article/details/108332389">传送门</a>进行了解。</p><p>所以，我们现在就得到了生成树。</p><h3 id="4、从生成树到最小生成树"><a href="#4、从生成树到最小生成树" class="headerlink" title="4、从生成树到最小生成树"></a>4、从生成树到最小生成树</h3><p>现在我们就可以为图中的每条边都加上权重，我们的目标很明确，就是要使得最后生成的树的所有权重之和最小。</p><p>比如，看下面这张图，我们现在想要使生成的树上所有边的权重和最小。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE6.jpg"></p><p>根据贪心算法，我们<strong>显然希望用尽量短的边来连通树</strong>。所以Kruskal算法的原理非常简单，就是对这些边的权值进行排序，依次从短到长遍历这些边，然后通过并查集来查询正在遍历的这条边是否能够被添加，直到所有边都遍历结束。</p><h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><h3 id="1、完美图解"><a href="#1、完美图解" class="headerlink" title="1、完美图解"></a>1、完美图解</h3><p>下面图解出自陈小玉老师所主编的书《趣学算法》中，朋友们可以借助理解算法。<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE7.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE8.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE9.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE10.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE11.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE12.jpg"></p><h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;#define VERTS 6  &#x2F;&#x2F;图的顶点数using namespace std;&#x2F;&#x2F;顶点的类class Edge&#123;public:    int from,to;  &#x2F;&#x2F;边依附的两个顶点    int find,weight;  &#x2F;&#x2F;边的权重    Edge *next;&#125;;int v[VERTS+1];Edge *findmincost(Edge *head);void mintree(Edge *head);int main()&#123;    &#x2F;&#x2F;各边状况    int data[10][3]&#x3D;&#123;&#123;1,2,6&#125;,&#123;1,6,12&#125;,&#123;1,5,10&#125;,                     &#123;2,3,3&#125;,&#123;2,4,5&#125;,&#123;2,6,8&#125;,                     &#123;3,4,7&#125;,&#123;4,6,11&#125;,&#123;4,5,9&#125;,&#123;5,6,16&#125;&#125;;    Edge *head,*newnode,*ptr;    &#x2F;&#x2F;建立图的链表    head&#x3D;NULL;    cout &lt;&lt; &quot;创建图的链表 ：&quot; &lt;&lt; endl;    for(int i&#x3D;1;i&lt;&#x3D;VERTS;i++)    &#123;        for(int j&#x3D;0;j&lt;10;j++)        &#123;            if(data[j][0]&#x3D;&#x3D;i)            &#123;                newnode&#x3D;new Edge;                newnode-&gt;from&#x3D;data[j][0];                newnode-&gt;to&#x3D;data[j][1];                newnode-&gt;weight&#x3D;data[j][2];                newnode-&gt;find&#x3D;0;                newnode-&gt;next&#x3D;NULL;                if(head&#x3D;&#x3D;NULL)  &#x2F;&#x2F;如果头结点为空，则创建新节点                &#123;                    head&#x3D;newnode;                    head-&gt;next&#x3D;NULL;                    ptr&#x3D;head;                &#125;                else                &#123;                    ptr-&gt;next&#x3D;newnode;                    ptr&#x3D;ptr-&gt;next;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F;打印图的链表    ptr&#x3D;head;    while(ptr!&#x3D;NULL)    &#123;        cout &lt;&lt; &quot;起始顶点 [&quot; &lt;&lt; ptr-&gt;from &lt;&lt; &quot;]&quot; &lt;&lt; setw(8)              &lt;&lt; &quot;终止顶点 [&quot; &lt;&lt; ptr-&gt;to &lt;&lt; &quot;]&quot;  &lt;&lt; setw(8)              &lt;&lt; &quot;路径长度 [&quot; &lt;&lt; ptr-&gt;weight &lt;&lt; &quot;]&quot; &lt;&lt; endl;        ptr&#x3D;ptr-&gt;next;  &#x2F;&#x2F;指针后移    &#125;    &#x2F;&#x2F;创建最小生成树    cout &lt;&lt; &quot;建立最小成本生成树：&quot; &lt;&lt; endl;    mintree(head);    delete newnode;    system(&quot;pause&quot;);    return 0;&#125;&#x2F;&#x2F;找到权值最小的边Edge *findmincost(Edge *head)&#123;    int minval&#x3D;100;  &#x2F;&#x2F;设置初始最小值    Edge *retptr,*ptr;    ptr&#x3D;head;    while(ptr!&#x3D;NULL)    &#123;        if(ptr-&gt;weight&lt;minval &amp;&amp; ptr-&gt;find&#x3D;&#x3D;0)        &#123;            &#x2F;&#x2F;假如ptr-&gt;val的值小于minval            minval&#x3D;ptr-&gt;weight;  &#x2F;&#x2F;将ptr-&gt;val设置最小值            retptr&#x3D;ptr;  &#x2F;&#x2F;并且记录ptr        &#125;        ptr&#x3D;ptr-&gt;next;    &#125;    retptr-&gt;find&#x3D;1;    return retptr;&#125;&#x2F;&#x2F;Kruscal算法实现最小生成树void mintree(Edge *head)&#123;    Edge *ptr,*mceptr;    int result&#x3D;0;  &#x2F;&#x2F;标识变量    &#x2F;&#x2F;初始化    for(int i&#x3D;0;i&lt;&#x3D;VERTS;i++)    &#123;        v[i]&#x3D;0;    &#125;    ptr&#x3D;head;    while(ptr!&#x3D;NULL)  &#x2F;&#x2F;画图比较形象    &#123;        mceptr&#x3D;findmincost(head);        v[mceptr-&gt;from]++;        v[mceptr-&gt;to]++;        if(v[mceptr-&gt;from]&gt;1 &amp;&amp; v[mceptr-&gt;to]&gt;1)        &#123;            v[mceptr-&gt;from]--;            v[mceptr-&gt;to]--;            result&#x3D;1;        &#125;        else        &#123;            result&#x3D;0;        &#125;        if(result&#x3D;&#x3D;0)        &#123;            cout &lt;&lt; &quot;起始顶点 [&quot; &lt;&lt; mceptr-&gt;from &lt;&lt; &quot;]&quot; &lt;&lt; setw(8)                  &lt;&lt; &quot;终止顶点 [&quot; &lt;&lt; mceptr-&gt;to &lt;&lt; &quot;]&quot;  &lt;&lt; setw(8)                  &lt;&lt; &quot;路径长度 [&quot; &lt;&lt; mceptr-&gt;weight &lt;&lt; &quot;]&quot; &lt;&lt; endl;        &#125;        ptr&#x3D;ptr-&gt;next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
