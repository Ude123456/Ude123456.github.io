<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习4：无监督学习</title>
      <link href="/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/"/>
      <url>/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、聚类算法之k-means"><a href="#一、聚类算法之k-means" class="headerlink" title="一、聚类算法之k-means"></a>一、聚类算法之k-means</h2><h3 id="1、什么是聚类"><a href="#1、什么是聚类" class="headerlink" title="1、什么是聚类"></a>1、什么是聚类</h3><ul><li>有监督学习<br>　—回归<br>　　a．线性回归<br>　　b．岭回归<br>　一分类<br>　　a．朴素贝叶斯<br>　　b．svm</li><li>无监督学习<br>　—聚类<br>　　k-means<br>　—降维<br>　　PCA降维</li></ul><h3 id="2、k-means算法运算步骤"><a href="#2、k-means算法运算步骤" class="headerlink" title="2、k-means算法运算步骤"></a>2、k-means算法运算步骤</h3><ul><li>假定我们要对N个样本观测做聚类，要求聚为K类：<br>1、初始化：选择K个点作为初始中心点<br>2、计算所有样本到所有中心点的距离（中心点的数量为k)<br>3、把样本归为距离中心点最近的类别（共k个类别）<br>4、计算每个类别内的样本均值<br>　　该均值作为新的中心点<br>5、重复第2-4步，直到结束。<br>　　结束条件：中心点不再改变或达到指定的迭代次数</li></ul><font size="5">k-means操作过程</font><p><img src="/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/图1.gif" alt="图1"></p><font size="5">距离</font><ul><li><p>欧氏距离</p></li><li><p>高维向量:<br>　　－A={$a_1,a_2,a_3,…a_n$}<br>　　－B={$b_1,b_2,b_3,…b_n$}<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　$D=\sqrt{(a_1-b_1)^2+(a_2-b_2)^2+…+(a_n-b_n)^2}$</p></li><li><p>每个数据分配给距离最近的类<br>　　－$arg\underset {j}{min}||x_n-C_j||^2$<br>　　－其中，$C_j$为聚类中心点</p></li></ul><h3 id="3、k-means算法效果的度量"><a href="#3、k-means算法效果的度量" class="headerlink" title="3、k-means算法效果的度量"></a>3、k-means算法效果的度量</h3><p><img src="/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/图2.jpg" alt="图2"></p><font size="5">K值怎么确定</font><ul><li><p>K设置得越大，样本划分得就越细，每个簇的聚合程度就越高，误差平方和SSE自然就越小</p></li><li><p>手肘法<br><img src="/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/图3.jpg" alt="图3"></p></li></ul><h2 id="二、降维"><a href="#二、降维" class="headerlink" title="二、降维"></a>二、降维</h2><h3 id="1、为什么降维"><a href="#1、为什么降维" class="headerlink" title="1、为什么降维"></a>1、为什么降维</h3><ul><li><p>高维的存在的问题：<br>　　—数据维数高<br>　　—算法适配困难<br>　　—计算速度慢<br>　　—模型效果差</p></li><li><p>降维的作用:<br>　　—通过获得一组基本上是重要特征的主变量来减少所考虑的特征变量的过程</p></li><li><p>降维的好处:<br>　　—数据需要的存储空间减少<br>　　—低维数据有助于减少训练时长<br>　　—一些算法在高维度数据上容易表现不佳<br>　　—降维可以用删除冗余特征解决多重共线性问题<br>　　—降维有助于数据可视化</p></li></ul><h3 id="2、降维的角度"><a href="#2、降维的角度" class="headerlink" title="2、降维的角度"></a>2、降维的角度</h3><ul><li><p>特征抽取</p></li><li><p>维度空间变换<br>　　—高维空间到低维空间的投影<br>　　—对高维的样本空间进行一种低纬度的描述</p></li><li><p>常用降维方法<br>　　—主成分分析PCA<br>　　—多维缩放(MDS)<br>　　—等度量映射(Isomap)<br>　　—局部线性嵌入(LLE)</p></li></ul><p><font size="5">PCA算法</font><br><img src="/2023/07/15/ji-qi-xue-xi-4-wu-jian-du-xue-xi/图4.jpg" alt="图4"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“机器学习3：支持向量机”</title>
      <link href="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/"/>
      <url>/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>支持向量机，SVM的全称是Support Vector Machine<br>支持向量机算法是一种二分类模型<br>核心思想：找到空间中的一个能够将所有数据样本划开的超平面，并且使得所有数据到这个超平面的距离最短</p></blockquote><h2 id="一、支持向量机的前导基本概念"><a href="#一、支持向量机的前导基本概念" class="headerlink" title="一、支持向量机的前导基本概念"></a>一、支持向量机的前导基本概念</h2><ul><li>$D_0$和$D_1$是$n$维欧氏空间中的两个点集</li><li>如果存在$n$维向量$w$和实数$b$</li><li>使得所有属于$D_0$的点都有$wx_i+b&gt;0$,</li><li>而对于所有属于$D_1$的点则有$wx_j+b&lt;0$,</li><li>则称$D_0$和$D_1$线性可分<br><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图1.jpg" alt><br>分类器应选择”正中间”，容忍性好，鲁棒性高，泛化能力最强</li></ul><h3 id="1、SVM最优化问题的数学推导"><a href="#1、SVM最优化问题的数学推导" class="headerlink" title="1、SVM最优化问题的数学推导"></a>1、SVM最优化问题的数学推导</h3><font size="5">点到线的距离</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图2.jpg" alt></p><font size="5">超平面公式演化</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图3.jpg" alt></p><font size="5">距离最大化</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图4.jpg" alt></p><p>s.t. = subject to</p><h3 id="2、拉格朗日乘数法"><a href="#2、拉格朗日乘数法" class="headerlink" title="2、拉格朗日乘数法"></a>2、拉格朗日乘数法</h3><font size="5">有约束优化问题的集合意象</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图5.jpg" alt></p><font size="5">拉格朗日乘数法定义——等式约束优化问题</font>- 拉格朗日乘数法(Lagrange multipliers,也译作拉格朗日乘子法)　　－是一种寻找多元函数在一组约束下的极值的方法- 多元函数微积分，以二元函数为例　　－目标函数：z=f(x,y)　　－约束条件：g(x,y)=0　　　　－拉格朗日辅助函数：$L(x,y,\lambda)=f(x,y)+{\lambda}g(x,y)$，其中，实数为拉格朗日乘数　　　　－求偏导数，令其为零，等到方程组：　　　　　　　　　$$ \begin{cases} L_x(x,y,\lambda)=f_x(x,y)+{\lambda}g_x(x,y)=0  \\ L_y(x,y,\lambda)=f_y(x,y)+{\lambda}g_y(x,y)=0 \\ L_{\lambda}(x,y,\lambda)=g_x(x,y)=0 \end{cases} \tag{1} $$　　　　－解此方程组，得到结果：$(x,y)$<font size="5">拉格朗日运算示例</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图6.jpg" alt></p><h3 id="3、凸优化问题"><a href="#3、凸优化问题" class="headerlink" title="3、凸优化问题"></a>3、凸优化问题</h3><font size="5">凸集</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图7.jpg" alt></p><font size="5">凸函数</font><ul><li>凸函数同时满足以下条件<br>　－函数的定义域是向量空间$R^n$上的凸集<br> －定义域内有任意两点$x_1$,$x_2$,并且，存在$\theta\in(0,1)$，得：<br>  　　　　　　　　$f({\theta}x_1+(1-{\theta})x_2)≤{\theta}f(x_1)+(1-{\theta})f(x_2)$<br>那么函数 $f(x)$ 为凸函数</li></ul><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图8.jpg" alt><br>弦一定在函数曲线的上方</p><font size="5">凸优化</font><ul><li><p>凸优化：凸优化是指一种比较特殊的优化，是指求取最小值的目标函数为凸函数的一类优化问<br>题。<br>　　其中<br>　　　-目标函数为凸函数且定义域为凸集的优化问题称为无约束凸优化问题。<br>　　　-目标函数和不等式约束函数均为凸函数，等式约束函数为仿射函数，并且定义域为凸集的　　　　　　优化问题为约束优化问题。</p></li><li><p>凸优化性质：<br>1、目的是求取目标函数的最小值；<br>2、目标函数和不等式约束函数都是凸函数，定义域是凸集;<br>3、若存在等式约束函数，则等式约束函数为仿射函数；<br>4、对于凸优化问题具有良好的性质，局部最优解便是全局最优解。　　　　　　　</p></li></ul><p>  　　　　　　　　　　　　　　　　　　　　　　　　　$\underset {x}{min} 　f(x)$<br>  　　　　　　　　　　　　　　　　　　　　　　　　　$s.t. 　h_i(x)=0 (i=1,..,m),$<br>  　　　　　　　　　　　　　　　　　　　　　　　　　$　　　g_j(x)≤0(j=1,..,n) .$</p><font size="5">KKT条件</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图9.jpg" alt></p><h3 id="4、拉格朗日对偶问题"><a href="#4、拉格朗日对偶问题" class="headerlink" title="4、拉格朗日对偶问题"></a>4、拉格朗日对偶问题</h3><ul><li>拉格朗日对偶问题的思路演进<br>　　　a.有约束的原始目标函数优化问题<br>   b.新构造的拉格朗日目标函数优化问题<br>   c.拉格朗日对偶函数的优化问题                        </li></ul><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图10.jpg" alt>　　　</p><font size="5">对偶问题</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图11.jpg" alt></p><h2 id="二、SVM最优化问题的计算"><a href="#二、SVM最优化问题的计算" class="headerlink" title="二、SVM最优化问题的计算"></a>二、SVM最优化问题的计算</h2><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图12.jpg" alt></p><ul><li>求阶SVM总共分为五步：</li><li>1）构造拉格朗日函数</li><li>2）构造拉格朗日对偶</li><li>3）使用SMO算法</li><li>4）计算参数值</li><li>5）预测</li></ul><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图13.jpg" alt></p><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图14.jpg" alt></p><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图15.jpg" alt></p><font size="5">SMO算法</font><ul><li>SMO(Sequential Minimal Optimization)算法<br>　－序列最小优化算法</li><li>核心思想<br>　　1）先固定住所有参数，然后放开一个参数<br>　　2）每次只优化这一个参数<br>　　3）仅求当前这个优化参数的极值</li></ul><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图16.jpg" alt></p><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图17.jpg" alt></p><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图18.jpg" alt></p><h2 id="三、软间隔，核函数，SVM优缺点分析"><a href="#三、软间隔，核函数，SVM优缺点分析" class="headerlink" title="三、软间隔，核函数，SVM优缺点分析"></a>三、软间隔，核函数，SVM优缺点分析</h2><h3 id="1、软间隔"><a href="#1、软间隔" class="headerlink" title="1、软间隔"></a>1、软间隔</h3><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图19.jpg" alt></p><p>现实任务中很难使得训练样本在特征空间中线性可分</p><ul><li>硬间隔约束条件：$y_i(wx_i+b)\geq1$<br>　　－引入“松弛变量”(slack variables) $\xi_{i}\geq0$，允许SVM在一些样本上出错，即允许某些样本不满足约束$y_i(wx_i+b)\geq1$</li></ul><p>　　－在最大化间隔的同时，不满足约束的样本应尽可能少<br>　<br>　　　　　　　$\underset {\omega,b,\xi_i}{min}\frac{1}{2}||\omega||^2+\lambda\sum\limits_{i=0}^{m}\xi_i$<br>　　　　　　　<br>　　　　　　$s.t. 　y_i(w^Tx_i+b)\geq1-\xi_i$<br>　　　　　　<br>　　　　　　　$\xi_i\geq0,i=1,2,…,m$<br>　<br>　　　　　<font color="red">$\lambda$ 越大，模型对分类错误的容忍度越低</font><br>　<br>　　　　　<font color="red">$\lambda$ 越小，模型对分类错误的容忍度越高</font></p><ul><li>hinge损失函数：$l_{hinge}(z)=max(0,1-z)$</li></ul><h3 id="2、核函数"><a href="#2、核函数" class="headerlink" title="2、核函数"></a>2、核函数</h3><font size="5">线性不可分</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图20.jpg" alt></p><font size="5">非线性可分</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图21.jpg" alt></p><font size="5">建立空间直角坐标系</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图22.jpg" alt></p><font size="5">数据升维</font><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图23.jpg" alt></p><ul><li>通过核函数来升维</li><li>旧目标函数：$f(x)=wx+b$</li><li>新目标函数：$f(x)=w\phi(x)+b$</li></ul><p><img src="/2023/07/13/ji-qi-xue-xi-3-zhi-chi-xiang-liang-ji/图24.jpg" alt></p><p><font size="5">常见的核函数</font></p><ul><li><p>线性核函数：$K(x_i,x_j)=x_i\times{x_j}$</p></li><li><p>多项式核函数：$K(x_i,x_j)=(x_i\times{x_j})^d$</p></li><li><p>高斯核函数：$K(x_i,x_j)=e^{(-\frac{||x_i-x_j||}{2\delta^2})}$</p></li></ul><h3 id="3、SVM的优缺点"><a href="#3、SVM的优缺点" class="headerlink" title="3、SVM的优缺点"></a>3、SVM的优缺点</h3><ul><li>优点<br>1）有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题；<br>2）能找出对任务至关重要的关键样本（即：支持向量）；<br>3）采用核技巧之后，可以处理非线性分类/回归任务；<br>4）最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。</li><li>缺点<br>1）训练时间长。当采用SMO算法时，由于每次都需要挑选一对参数，因此时间复杂度为$O(N^2)$,其中N为训练样本的数量；<br>2）当采用核技巧时，如果需要存储核矩阵，则空间复杂度为$O(N^2)$<br>3）模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。</li></ul><p>因此样本数量较大时,我们使用深度学习算法</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习2：朴素贝叶斯</title>
      <link href="/2023/07/13/ji-qi-xue-xi-2-po-su-bei-xie-si/"/>
      <url>/2023/07/13/ji-qi-xue-xi-2-po-su-bei-xie-si/</url>
      
        <content type="html"><![CDATA[<h1 id="一、贝叶斯决策论"><a href="#一、贝叶斯决策论" class="headerlink" title="一、贝叶斯决策论"></a>一、贝叶斯决策论</h1><ul><li><p>贝叶斯决策论(Bayesian decision theory)是采用概率方法进行决策的基本方法。</p></li><li><p>首先，使用主观概率，对未知状态进行概率估计</p></li><li>然后，采用贝叶斯公式做概率上的修正</li><li><p>最后，利用计算得到的期望概率值与修正后得到的概率做出最后的决策</p></li><li><p>贝叶斯方法的综合判别能力很强</p></li></ul><h1 id="二、朴素贝叶斯法概述"><a href="#二、朴素贝叶斯法概述" class="headerlink" title="二、朴素贝叶斯法概述"></a>二、朴素贝叶斯法概述</h1><ul><li><p>朴素贝叶斯法(Naive Bayes)<br>　　－基于贝叶斯定理与特征条件独立假设的分类方法。</p></li><li><p>核心思想<br>　　－对于给定的训练数据集<br>　　－首先，基于特征条件独立假设学习输入/输出的联合概率分布<br>　　－然后，基于此模型，对给定的输入x,利用贝叶斯定理求出后验概率最大的输出y<br>　　－y即为对应的类别</p></li><li><p>朴素贝叶斯算法，常用作自然语言处理的文本分类任务。</p></li></ul><h2 id="1、朴素贝叶斯法的前导知识"><a href="#1、朴素贝叶斯法的前导知识" class="headerlink" title="1、朴素贝叶斯法的前导知识"></a>1、朴素贝叶斯法的前导知识</h2><ul><li>先验概率</li><li>条件概率</li><li>全概率公式</li><li>后验概率</li></ul><h2 id="2、朴素贝叶斯的算法流程"><a href="#2、朴素贝叶斯的算法流程" class="headerlink" title="2、朴素贝叶斯的算法流程"></a>2、朴素贝叶斯的算法流程</h2><ul><li><p>朴素贝叶斯算法总共有三步：</p><p>　a. 计算先验概率<br>  　　－统计样本集中样本总量$|D|$<br>  　　－求出类别的可取值的个数$K$<br>  　　－对每个类别统计样本数量$|y_k|$<br>  　　－计算出所有的频率，并用频率逼近概率：$P(y_k)$</p><p>  　b. 计算条件概率<br>  　　－将样本集划分成$K$个子样本集，记作$D_k$<br>  　　－分别对每个样本子集进行计算<br>  　　　　－统计该子集中每个属性a的取值为$I$的样本的数量，记作$|a_{jI}|$<br>  　　　　－于是，可得$P(a_{jI}|y_k)=\frac{|a_{jI}|}{|D_k|}$</p><p>  　c. 预测<br>  　　－针对待预测样本t,计算其对于每个类别y的后验概率<br>  　　－计算结果概率值最大的类别即为待预测样本的预测类别</p></li></ul><h2 id="3、朴素贝叶斯算法的优缺点分析"><a href="#3、朴素贝叶斯算法的优缺点分析" class="headerlink" title="3、朴素贝叶斯算法的优缺点分析"></a>3、朴素贝叶斯算法的优缺点分析</h2><ul><li><p>优点：</p><p>－朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率<br>－对小规模的数据表现很好<br>－对缺失数据不太敏感</p></li><li><p>缺点：<br>－理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率<br>－需要知道先验概率<br>－各个属性间是独立的，这个前提假设太强</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习1：决策树</title>
      <link href="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/"/>
      <url>/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、决策树的描述"><a href="#一、决策树的描述" class="headerlink" title="一、决策树的描述"></a>一、决策树的描述</h2><p><strong>决策树（decision tree）</strong></p><p>— 一种监督学习方法</p><p>— 优点</p><ul><li>速度快</li><li>易于理解、可解释性强</li><li>需要样本量小</li></ul><p>— 任务类型</p><ul><li>分类</li><li>回归</li></ul><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图1.jpg" alt></p><ul><li><p>决策树一般分三步，</p><p>（1）<strong>特征选择</strong></p><p>（2）<strong>决策树生成</strong></p><p>（3）<strong>决策树剪枝</strong></p></li></ul><h3 id="1、度量混乱程度——信息熵"><a href="#1、度量混乱程度——信息熵" class="headerlink" title="1、度量混乱程度——信息熵"></a>1、度量混乱程度——信息熵</h3><font color="red">“信息熵”是度量样本级和纯度最常用的一种指标。</font><p>热力学里有一个熵的概念，熵就是来形容系统混乱程度的，系统越混乱，熵就越大。信息熵也具有同样的意义，不过它描述的是随机变量的不确定性（也就是混乱程度）。</p><ul><li><p>假定当前样本集合D中第K类样本所占的比例记作：$p_k(k=1,2,…,|y|)$</p></li><li><p>则它的信息熵计算公式为：<br>　　　　　　　　　　$H(D)=-\sum\limits_{i=0}^{|y|}p_klogp_k$<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　因而可计算出例子中的信息熵：</p></li></ul><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图2.jpg" alt></p><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图3.jpg" alt></p><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图4.jpg" alt></p><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图5.jpg" alt></p><p><strong>从上面的计算结果中可以看出，信息熵越大，纯度越低。当集合中所有样本均匀混合时，信息熵越大，纯度越低。</strong></p><font size="4">信息熵计算练习：</font><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图6.jpg" alt></p><h3 id="2、信息增益"><a href="#2、信息增益" class="headerlink" title="2、信息增益"></a>2、信息增益</h3><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图7.jpg" alt></p><ul><li><p>设离散属性a有V个可能的取值{$a^1$,$a^2$,…,$a^v$}</p></li><li><p>若用a来进行划分，则会产生V个分支节点</p></li><li><p>其中第v个分支节点包含了D中所有在属性a上取值为$a^v$的样本，记为$D^v$</p></li><li><p>那么可计算出属性a对样本集D进行划分所获得的“信息增益”为：</p><script type="math/tex; mode=display">Gain(D,a)=H(D)-\sum\limits_{v=0}^{v}\frac{|D^v|}{|D|}H(D^v)</script><p>其中，$\frac{|D^v|}{|D|}H(D^v)$也被称为<strong>条件熵</strong></p></li></ul><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图8.jpg" alt></p><h2 id="二、构建决策树"><a href="#二、构建决策树" class="headerlink" title="二、构建决策树"></a>二、构建决策树</h2><p><strong>ID3决策树算法</strong>使用<font color="red">信息增益</font>来构建决策树，对于所有的属性我们先选择信息增益最大的作为根节点，然后计算其他属性的信息增益再选择最大的作为子节点，一直<strong>递归</strong>调用该操作，直到信息增益很小或者没有特征为止。</p><p><strong>ID3算法的优缺点：</strong></p><ul><li><p>优点：</p><p>a. 假设空间包含所有的决策树，搜索空间完整</p><p>b. 健壮性好，不受噪声影响</p><p>c. 算法直观、可解释性强。</p></li><li><p>缺点：</p><p>a. 只能处理离散值的属性。</p><p>b. 容易产生过拟合的问题</p><p>c. 采用了信息增益作为评价标准</p></li></ul><p><strong><font size="5">信息增益比</font></strong></p><p>信息增益比定义：$Gain_ratio(D,a)=G_r(D,a)=\frac{Gain(D,a)}{IV(a)}$</p><p>其中</p><script type="math/tex; mode=display">IV(a)=-\sum\limits_{V=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}</script><p>称为属性a的“固有值”，属性a的可能取值数目越多（即V越大），则$IV(a)$的值通常就越大。<br><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图9.jpg" alt></p><h2 id="三、离散化、缺失值、剪枝"><a href="#三、离散化、缺失值、剪枝" class="headerlink" title="三、离散化、缺失值、剪枝"></a>三、离散化、缺失值、剪枝</h2><h3 id="1、连续性属性值的离散化"><a href="#1、连续性属性值的离散化" class="headerlink" title="1、连续性属性值的离散化"></a>1、连续性属性值的离散化</h3><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图10.jpg" alt></p><h3 id="2、缺失值处理中的问题"><a href="#2、缺失值处理中的问题" class="headerlink" title="2、缺失值处理中的问题"></a>2、缺失值处理中的问题</h3><ul><li><p>不完整样本，即样本的属性值缺失</p></li><li><p>仅使用无缺失的样本进行学习？</p></li></ul><p>　　　对数据信息极大的浪费</p><ul><li>使用有缺失值的样本，需要解决哪些问题？</li></ul><p>　　　Q1：在训练时，如何在属性值缺失的情况下进行划分属性选择？<br>　　　<br>　　　Q2：在训练时，给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？<br>　　　<br>　　　Q3：在预测时，若属性值缺失，如何计算？</p><h4 id="2-1-缺失值处理"><a href="#2-1-缺失值处理" class="headerlink" title="2.1 缺失值处理"></a>2.1 缺失值处理</h4><font size="5">Q1:</font><p><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图11.jpg" alt><br><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图12.jpg" alt></p><font size="5">Q2:</font><ul><li><p>若样本$x$在划分属性a上的取值已知，则将$x$划入与其取值对应的子结点，且样本权值在子结点中保持为$w_x$</p></li><li><p>若样本$x$在划分属性a上的取值未知，则将$x$同时划入所有子结点，且样本权值在与属性值$a_v$对应的子结点中调整为$\widetilde{r_v}\times{w}$(直观来看，相当于让同一个样本以不同概率划入不同的子结点中去)</p></li></ul><font size="5">Q3:</font><ul><li>若样本$x$在属性a上的取值已知，则正常按照属性值在决策树上移动</li><li>若样本$x$在属性a上的取值未知：<br>　　　－直接给出分类结果<br>　　　－人为赋予最常见的值，然后继续分类过程</li></ul><h3 id="3、剪枝策略"><a href="#3、剪枝策略" class="headerlink" title="3、剪枝策略"></a>3、剪枝策略</h3><ul><li>剪枝的原因：提高泛化能力</li><li>预剪枝<br>－节点内数据样本低于某一阈值<br>－所有节点特征都已分裂<br>－节点划分前准确率比划分后准确率高</li><li>后剪枝<br>－悲观剪枝方法<br>－训练数据集上的错误分类数量来估算未知样本上的错误率</li></ul><p><font size="5">C4.5算法流程图</font><br><img src="/2023/07/12/ji-qi-xue-xi-1-jue-ce-shu/图13.jpg" alt></p><h2 id="四、决策树的优缺点分析"><a href="#四、决策树的优缺点分析" class="headerlink" title="四、决策树的优缺点分析"></a>四、决策树的优缺点分析</h2><ul><li>优点<br>－可解释性强<br>－图形化和直观化<br>－需要训练的数据更少<br>－可同时用于分类和回归<br>－模型复杂度低<br>－对缺失值的容忍度较高</li><li>缺点<br>－很容易出现过拟合，对异常值敏感<br>－学习能力不强</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表</title>
      <link href="/2022/11/14/san-lie-biao/"/>
      <url>/2022/11/14/san-lie-biao/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>顺序存储的结构类型有顺序表、栈、队列等，但他们都需要一个一个地按顺序对元素进行访问，如果要访问的总量很大时候，并且当我们要访问的这一元素位于末尾时，则查找效率就会很低。<br>散列表是一种<strong>空间换时间</strong>的存储结构，就是牺牲了存储空间来换取了查找数据的效率，但是如果需要的存储空间太大时，也会让我们感到头疼，所以我们往往需要在空间和时间两者当中进行权衡。</p><hr><h2 id="1、什么是散列表"><a href="#1、什么是散列表" class="headerlink" title="1、什么是散列表"></a>1、什么是散列表</h2></blockquote><p>如果在图书馆里要找一本书，那我们应该不会从第 1 本书一直找下去，因为这样实在是太慢了。回想一下我们到图书馆找书是怎么找的呢？首先是不是应该先找到你要找的这本书属于什么类别，例如科幻类、古典文学、武侠类等等，然后再在这一个类别当中进行查找。</p><p>还有我们平常学英语应该也要查字典，那么要查找一个单词的时候，我们肯定不会从头翻到尾，而是首先通过这个单词的首字母，找到对应的那一页；再找第 2 个字母、第 3 个字母……这样可以快速跳到那个单词所在的页。</p><p>其实这些就是运用了散列表的思想：在记录的存储地址和它的关键码之间建立一个确定的对应关系。这样，不需要经过比较，一次读取就能够得到所查元素。</p><p>散列表（Hash table，也叫哈希表），是<strong>根据键（Key）而直接访问在内存储存位置</strong>的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。<strong>这个映射函数称做散列函数，存放记录的数组称做散列表，由散列函数所得的存储地址称做散列地址</strong>。<br><img src="/2022/11/14/san-lie-biao/图1.png" alt><br>从上图中，我们也可以看出散列表不仅仅只是一种查找技术，同时也是一种存储技术。另外，从散列表的定义，我们也可以发现，散列方法是不适用于范围查找的，换言之，在散列表中，我们不可能找到最大或最小关键码的记录，也不可能找到在某一范围内的记录。</p><p>那么散列表的关键值都要不同，这时我们会发现出现一个严重的问题，如果对于两个不同的数据 ，我们计算到了同样的键值，那么就会出现冲突，此时该如何处理呢？</p><p>所以构造一个好的散列表，最重要的是做好以下两个步骤：</p><ol><li>设计一个”好”的散列函数来计算Key值。(好的哈希函数应尽可能避免冲突的出现，而且计算时应尽可能简洁快速)</li><li>出现了冲突时又该如何调整插入元素。</li></ol><hr><h2 id="2、散列函数设计方法"><a href="#2、散列函数设计方法" class="headerlink" title="2、散列函数设计方法"></a>2、散列函数设计方法</h2><h3 id="1、直接寻址法"><a href="#1、直接寻址法" class="headerlink" title="1、直接寻址法"></a>1、直接寻址法</h3><p>散列函数是关键码的线性函数，即：<br>　$H(key)=a\times key + b $    式中，a 和 b 是常数</p><p>例如：关键码集合为{10,20,30,40,60,80,90}，选取一个散列函数为：$H(key)=\frac{1}{10}key$ ,则散列表为：<br><img src="/2022/11/14/san-lie-biao/图2.png" alt><br>适用情况：事先知道关键码，关键码集合<strong>不是很大并且连续性较好</strong>。</p><h3 id="2、除留余数法"><a href="#2、除留余数法" class="headerlink" title="2、除留余数法"></a>2、除留余数法</h3><p>假设散列表长度为 n，取一个不大于 n 但近似接近或等于 m 的质数 p，利用除留余数法的散列函数把关键字转换成散列地址。</p><p>散列函数为：<br>　$ H(key)=key\quad mod\quad p $    </p><p>例如，数据元素集合为a={78,7,99,13,25,53,59,30}，哈希表长度n取11时，并不会产生哈希冲突；当n取9时，就会产生哈希冲突。p的选取并不是固定的，需要自己进行判断，以此来选择最合适的p值。</p><p>通常情况下，哈希表的长度n习惯选取<strong>质数</strong>。<strong>对p的选择也十分重要，一般取素数或m</strong>，这样可以有效减少哈希冲突的发生。</p><p>在来看一个例子：现在有一组关键码，我们取p=21，则会得到以下信息：<br><img src="/2022/11/14/san-lie-biao/图3.png" alt><br>适用情况：除留余数法是一种最简单、也是最常见的构造散列函数的方法，并且<strong>不需要事先知道关键码的分布</strong>。</p><h3 id="3、数字分析法"><a href="#3、数字分析法" class="headerlink" title="3、数字分析法"></a>3、数字分析法</h3><p>如果关键字是位数较多的数字（比如手机号和学号），且这些数字部分存在相同规律，则可以采用抽取剩余不同规律部分作为散列地址。</p><p>如下图所示，有80个记录，每一行为一个记录中的键，假设表长为100，则可取两位十进制数组成哈希地址。<br><img src="/2022/11/14/san-lie-biao/图4.png" alt><br>通过对上图进行观察可以得出，第1,2列对应的数字都是相同的，而第3列和第8列存在着大量重复的数字（分别是3和2,7），因此不能选择它们成为哈希地址。而中间4位可以看作是随机的，所以可以从中任选两位作为哈希地址。</p><p>再来看一个更直白的应用，现在有一组学生的学号为：<br><img src="/2022/11/14/san-lie-biao/图5.png" alt><br>这组学号的前7位取值相对比较集中，剩下的后两位取值较均匀，可以直接使用学号的最后两位作为哈希地址，所以这十个关键字的哈希地址分别为：<br>10、21、71、85、13、37、22、33、3、14。</p><p>适用情况：能预先估计出关键码的每一位上各种数字出现的频度，不同的关键码集合需要重新分析。</p><h3 id="4、平方取中法"><a href="#4、平方取中法" class="headerlink" title="4、平方取中法"></a>4、平方取中法</h3><p>对关键码平方后，按散列表大小，取中间若干位作为散列地址（<strong>平方</strong>后<strong>截取</strong>）。</p><p>它弥补了数字分析法的一些缺陷，因为我们有时并不能知道键的全部情况，取其中几位也不一定合适，而一个数平方后的中间几个数和原数的每一位都相关，由此我们就能得到随机性更强的哈希地址取的位数由表长决定。<br><img src="/2022/11/14/san-lie-biao/图6.png" alt><br>适用情况：事先不知道关键码的分布并且<strong>关键码的位数不是很大</strong>。</p><h3 id="5、折叠法"><a href="#5、折叠法" class="headerlink" title="5、折叠法"></a>5、折叠法</h3><p>将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>例如：设关键码为<u>2 5 3</u> <u>4 6 3</u> <u>5 8 7</u> <u>0 5</u>，散列地址为三位。<br><img src="/2022/11/14/san-lie-biao/图7.png" alt><br>适用情况：<strong>关键码很多</strong>，事先不知道关键码的分布。</p><hr><h2 id="3、解决冲突的方法"><a href="#3、解决冲突的方法" class="headerlink" title="3、解决冲突的方法"></a>3、解决冲突的方法</h2><p>我们在前面已经说过了，我们在构建散列表时，一个经常会碰到的问题是：不同的关键值经过散列函数的映射后，得到了一个同样的散列地址，这种现象就叫做冲突。那我们该如何解决冲突呢，方法总共有两类：开放定址法和拉链法。</p><p>用开放定址法处理冲突得到的散列表叫<strong>闭散列表</strong>；用拉链法处理冲突构造出的散列表叫<strong>开散列表</strong>。</p><h3 id="1、开放定址法"><a href="#1、开放定址法" class="headerlink" title="1、开放定址法"></a>1、开放定址法</h3><p>当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。<br>基本公式为：$H(key) = (key+di)\quad mod\quad TableSize$。注意，这里是一个递归序列，<strong>其中$d_i$为增量序列，TableSize为散列表长</strong>。<br>根据$d_i$的不同我们又可以分为线性探测，平方（二次）探测，随机探测。</p><h4 id="1、线性探测法"><a href="#1、线性探测法" class="headerlink" title="1、线性探测法"></a>1、线性探测法</h4><p>以增量序列 1，2，……，（TableSize -1）进行循环试探下一个存储地址，即$d_i$ = i。</p><p>例：关键码集合为{47,7,29,11,16,92,22,8,3}，散列表表长为11，散列函数为$H(key)=key\quad mod\quad 11 $，用线性探测法处理冲突，则散列表为：<br><img src="/2022/11/14/san-lie-biao/图8.png" alt><br>通过上图，我们会发现计算散列地址时，较多的元素计算出散列地址为7，图中出现了<strong>堆积</strong>（在处理冲突的过程中会出现<strong>非同义词</strong>之间对同一个散列地址争夺的现象，这种现象就称为堆积现象。）的现象，明明还有空间，却都往一个地方挤。堆积地方的冲突会越来越多。</p><h4 id="2、平方探测法"><a href="#2、平方探测法" class="headerlink" title="2、平方探测法"></a>2、平方探测法</h4><p>以增量序列$1^2$，$-1^2$，$2^2$，$-2^2$，……，$q^2$，$-q^2$ 且$q$ ≤ $\frac{TableSize}{2}$进行循环试探下一个存储地址。</p><p>同上一个例子相同，关键码集合、散列表和散列函数均不做改变，用平方探测法处理冲突，则散列表为：<br><img src="/2022/11/14/san-lie-biao/图9.png" alt><br>我们可以发现平方探测法是跳着寻找位置的，那么就会存在一个问题，假设散列表中还有空间，平方探测(二次探测)就一定能找得到？举个例子说明一下：<br><img src="/2022/11/14/san-lie-biao/图10.png" alt><br>散列函数为$H(key)=key\quad mod\quad 5$，用平方探测来处理冲突。<br>我们假设下一个插入11，则H(11)=1，探测序列：1+1=2, 1-1=0, (1+$2^2$) mod 5=0, (1-$2^2$) mod 5=2，(1+$3^2$) mod 5=0, (1-$3^2$) mod 5=2, (1+$4^2$) mod 5=2,$\cdots\cdots$我们可以看到，存放11元素的地址在地址0与地址2之间往复横跳，虽然地址3和地址4位置是有空位，但是却找不到这个空间。<strong>解决方法</strong>：有定理显示，如果散列表长度TableSize是某个$\color{red}{4k+3}$（k是正整数)形式的$\color{red}{素数}$时，平方探测法就可以探查到整个散列表空间。</p><h4 id="3、随机探测法"><a href="#3、随机探测法" class="headerlink" title="3、随机探测法"></a>3、随机探测法</h4><p>以增量序列是伪随机数来进行循环试探下一个存储地址。</p><p>计算机产生随机数的方法通常采用线性同余法，<br>　　<script type="math/tex">\begin{cases}a_0=d &  \\a_n=(ba_{n-1}+c)\;mod\;m & n=1,2,\cdots \\\end{cases}</script><br>其中，d称为随机种子。当b、c和m的值确定后，给定一个随机种子，产生确定的随机数序列。</p><h3 id="2、拉链法（链地址法）"><a href="#2、拉链法（链地址法）" class="headerlink" title="2、拉链法（链地址法）"></a>2、拉链法（链地址法）</h3><p>对于不同的关键字可能会通过散列函数映射到同一地址，为避免非同义词发生冲突，把所有散列地址相同的记录，即所有同义词记录存储在一个线性链表中（称为同义词子表），在散列表中存储的是所有同义词子表的头指针。最开始我们已经说过了，用拉链法处理冲突构造出的散列表叫做<strong>开散列表</strong>。开散列表是不会出现堆积现象的。设n个记录存储在长度为m的散列表中，则同义词子表的平均长度为$\frac{n}{m}$。</p><p>关键字序列为 {15,16,29,37,48,12,25,56,67,47,22,34}，应用拉链法处理冲突的散列表如下图所示：<br><img src="/2022/11/14/san-lie-biao/图11.png" alt><br>当单链表无法满足查找需求时，或者说单链表过长导致查找效率过低时，我们可以将单链表改成平衡二叉树或者红黑树进行数据的存储和查找，如下图所示：<br><img src="/2022/11/14/san-lie-biao/图12.png" alt></p><h2 id="4、散列查找的性能分析"><a href="#4、散列查找的性能分析" class="headerlink" title="4、散列查找的性能分析"></a>4、散列查找的性能分析</h2><ul><li>由于冲突的存在，产生冲突后的查找仍然是给定值与关键码进行比较的过程。</li><li>在查找过程中，关键码的比较次数取决于产生冲突的概率。影响冲突产生的因素有：<br>（1）散列函数是否均匀<br>（2）处理冲突的方法<br>（3）散列表的装载因子<br>　　　　$\alpha= \frac{表中填入的记录数}{散列表的长度} $</li><li>几种处理冲突方法的<strong>平均查找长度（ASL）</strong><br><img src="/2022/11/14/san-lie-biao/图13.png" alt><blockquote><p>散列表的平均查找长度是$\color{red}{装填因子\alpha的函数}$，而不是查找集合中记录个数n的函数。在很多情况下，散列表的空间都比查找集合大，此时虽然浪费了一定的空间，但换来的是查找效率。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2022/11/12/hong-hei-shu/"/>
      <url>/2022/11/12/hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>学过了二叉查找树还有平衡二叉树以后，再看点更复杂的树形结构——红黑树，跟平衡二叉树一样，红黑树也是为了解决二叉搜索树不能自平衡的问题。红黑树是2-3树的变形，以2-3树的角度去理解红黑树会容易的多。</p><hr><p>先回忆一下AVL树：<br><img src="/2022/11/12/hong-hei-shu/图1.png" alt><br>AVL树就是要保证插入结点后，任一结点对应的两棵子树的最大高度差为1，这样就可以保证整棵树的深度最小。</p></blockquote><p>AVL虽然高度平衡，但是我们发现它每次插入或者删除结点的时候，树的平衡都可能被打破，而且如果要一直保证也就是动态的来使得这个 AVL 树达到平衡是需要很多操作的，太多步的操作反而会影响这个树形结构的的性能。除非是在树结构变化特别少的情况，不然我们让AVL 树平衡的时候，搜索性能的提升可能还不够抵消平衡树所带来的性能消耗。所以就相继出现了2-3树和红黑树。</p><hr><h2 id="1、2-3树"><a href="#1、2-3树" class="headerlink" title="1、2-3树"></a>1、2-3树</h2><h3 id="1、什么是2-3树"><a href="#1、什么是2-3树" class="headerlink" title="1、什么是2-3树"></a>1、什么是2-3树</h3><p>2-3树的意思就是说，一个父节点可以有两个子结点，也可以有三个子结点，并且其也满足类似二叉搜索树的定义（父结点的值大于左子树，但小于右子树），所有叶子节点都在同一层。</p><p>2-3树的某个节点会有两种可能，一是正常的2节点，二是3节点：</p><ul><li>2节点：父亲节点存储一个值，最多有左右两个子树。假设父节点为p，子节点为l(左节点)、r(有节点)，且满足：<br>　　　　　　<script type="math/tex">l < p < r</script><br>如下图：<br><img src="/2022/11/12/hong-hei-shu/图2.png" alt></li><li>3节点：父亲节点存储两个值，最多有左中右三个子树。假设父节点分别为p1,p2，子节点分别为l(左节点)、m(中间节点)、r(右节点)，且满足：<br>　　　　　<script type="math/tex">\begin{cases}l < p1  \\p1 < m < p2\\r > p2\\\end{cases}</script><br>如下图：<br><img src="/2022/11/12/hong-hei-shu/图3.png" alt><br>一颗完整的2-3树就如下图所示：<br><img src="/2022/11/12/hong-hei-shu/图4.png" alt></li></ul><h3 id="2、2-3树的创建"><a href="#2、2-3树的创建" class="headerlink" title="2、2-3树的创建"></a>2、2-3树的创建</h3><p>假设有一组数据集合数组为<strong>{ 30, 13, 7, 43, 23, 12, 9, 33, 42, 21, 18, 6, 3, 50 }。</strong></p><p>创建2-3树的过程：</p><p>1、将30作为根节点<br><img src="/2022/11/12/hong-hei-shu/图5.png" alt><br>2、插入13，13比30小，融合成一个值为（13  30）的3节点<br><img src="/2022/11/12/hong-hei-shu/图6.png" alt><br>3、插入7，7比13小，融合成一个值为（7  13  30）的4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/图7.png" alt><br>4、插入43，43大于13，43大于30，与30一起融合成3节点<br><img src="/2022/11/12/hong-hei-shu/图8.png" alt><br>5、插入23，23大于13，23小于30，与（30  43）融合成4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/图9.png" alt><br>6、插入12，12小于13，12大于7，与7融合成3节点<br><img src="/2022/11/12/hong-hei-shu/图10.png" alt><br>7、插入9，9小于13，9大于7，9小于12，与（7  12）融合成4节点，然后分解。分解后9升级到上一层，与（13  30）融合成4节点，再次分解<br><img src="/2022/11/12/hong-hei-shu/图11.png" alt><br>8、插入33，33大于13，33大于30，33小于43，与43融合成3节点<br><img src="/2022/11/12/hong-hei-shu/图12.png" alt><br>9、插入42，42大于13，42大于30，42大于33，42小于43，与（33  43）融合成4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/图13.png" alt><br>10、省略后面过程，最终生成结果为：<br><img src="/2022/11/12/hong-hei-shu/图14.png" alt><br>至此，我们创建了一颗2-3树，可以看出2-3树的平衡性还是很好的。</p><h2 id="2、红黑树"><a href="#2、红黑树" class="headerlink" title="2、红黑树"></a>2、红黑树</h2><hr><blockquote><p>尽管有平衡二叉树和2-3树了，但是现在用的多的还是红黑树，主要是因为红黑树有这4点的优势：<br>1、AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡。<br>2、在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣。<br>3、红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL。（红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决。）<br>4、红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。</p><hr><h3 id="1、将2-3树转换成红黑树"><a href="#1、将2-3树转换成红黑树" class="headerlink" title="1、将2-3树转换成红黑树"></a>1、将2-3树转换成红黑树</h3><p>创建了一棵2-3树以后，我们就可以进行一些结构上的变化<br>将所有的3节点进行变换，并且满足三个条件：</p><ul><li>红链接均为左链接。</li><li>没有任何一个节点同时和两条红链接相连。</li><li>任意空链接到根节点路径上的黑色连接数目相同。</li></ul></blockquote><p>这三个条件均满足以后我们创建的就是一棵不那么标准的红黑树，如下图：<br><img src="/2022/11/12/hong-hei-shu/图15.png" alt></p><h3 id="2、红黑树的性质"><a href="#2、红黑树的性质" class="headerlink" title="2、红黑树的性质"></a>2、红黑树的性质</h3><p>红黑树本身是一棵二叉查找树，在其基础上附加了两个要求：</p><ul><li>树中的每个结点增加了一个用于存储颜色的标志域；</li><li>树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。</li></ul><hr><blockquote><p>路径：指的是从任何一个结点开始，一直到其子孙的叶子结点的长度；<br>接近于平衡：红黑树并不是平衡二叉树，只是由于对各路径的长度之差有限制，所以近似于平衡的状态。</p><hr><p>下面图示的就是一棵典型的红黑树：<br><img src="/2022/11/12/hong-hei-shu/图16.png" alt></p><hr><p>观察上图，可以发现红黑树的一些规律：<br>1、这些节点<strong>不是红色的就是黑色的</strong>，但是<strong>根节点是黑色的</strong>。<br>2、再看叶子节点，叶子节点跟普通的树不太一样，<strong>红黑树的叶子节点都是null节点（空节点）并且都为黑色的</strong>。<br>3、假设从根节点出发，然后从最左边的路径走到叶子节点，都没有连续的红色节点。所以可以得出一个结论，<strong>同一路径，不存在连续的红色节点</strong>。<br>以上观察出来的这三条规律就是红黑规则的一部分。</p><hr><p>因此我们就可以得出红黑树的红黑规则了：</p></blockquote><ul><li>性质1：每个结点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子结点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li><li>从性质5又可以推出：<pre><code>    性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</code></pre></li></ul><h3 id="3、红黑树的术语约定"><a href="#3、红黑树的术语约定" class="headerlink" title="3、红黑树的术语约定"></a>3、红黑树的术语约定</h3><p><img src="/2022/11/12/hong-hei-shu/图17.png" alt><br>正在遍历的结点称做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做叔叔结点，父亲的父亲叫做祖父结点。</p><h3 id="4、红黑树基本操作"><a href="#4、红黑树基本操作" class="headerlink" title="4、红黑树基本操作"></a>4、红黑树基本操作</h3><blockquote><p>$\color{red}{红黑树总是通过旋转和变色达到自平衡}$</p></blockquote><p>1、左旋<br><img src="/2022/11/12/hong-hei-shu/图18.gif" alt></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void left_rotate(RBT_Node* x) &#x2F;&#x2F;x 表示需要进行左旋的子树的根结点&#123;RBT_Node* y &#x3D; x-&gt;right_Child;  &#x2F;&#x2F;找到根节点的右子树    x-&gt;right_Child &#x3D; y-&gt;left_Child;  &#x2F;&#x2F;将右子树的左孩子移动至节点x的右孩子处            &#x2F;&#x2F;y所指结点的左结点不为空    if (y-&gt;left_Child !&#x3D; nil)    &#123;    y-&gt;left_Child-&gt;parent &#x3D; x;&#125;    y-&gt;parent &#x3D; x-&gt;parent;  &#x2F;&#x2F;设置y的双亲结点为x的双亲节点            &#x2F;&#x2F;判断x节点是不是其父节点的左右子树    if (x-&gt;parent &#x3D;&#x3D; nil)    &#123;root &#x3D; y;&#125;else if (x-&gt;parent-&gt;left_Child &#x3D;&#x3D; x)&#x2F;&#x2F;x在左子树    &#123;x-&gt;parent-&gt;left_Child &#x3D; y;&#125;    else  &#x2F;&#x2F;x在右子树    &#123;    x-&gt;parent-&gt;right_Child &#x3D; y;    &#125;    x-&gt;parent &#x3D; y;    y-&gt;left_Child &#x3D; x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、右旋<br><img src="/2022/11/12/hong-hei-shu/图19.gif" alt></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;右旋操作（与左子树操作基本相同）void right_rotate(RBT_Node* x)&#123;RBT_Node* y &#x3D; x-&gt;left_Child;x-&gt;left_Child &#x3D; y-&gt;right_Child;if (y-&gt;right_Child !&#x3D; nil)&#123;y-&gt;right_Child-&gt;parent &#x3D; x;&#125;y-&gt;parent &#x3D; x-&gt;parent;if (x-&gt;parent &#x3D;&#x3D; nil)&#123;root &#x3D; y;&#125;else if (x-&gt;parent-&gt;left_Child &#x3D;&#x3D; x)&#123;x-&gt;parent-&gt;left_Child &#x3D; y;&#125;else&#123;x-&gt;parent-&gt;right_Child &#x3D; y;&#125;x-&gt;parent &#x3D; y;y-&gt;right_Child &#x3D; x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/12/hong-hei-shu/图20.png" alt></p><p>3、变色</p><p>结点的颜色由红变黑或由黑变红。</p><h3 id="5、红黑树的插入"><a href="#5、红黑树的插入" class="headerlink" title="5、红黑树的插入"></a>5、红黑树的插入</h3><blockquote><p>在创建红黑树或者向已有红黑树中添加新的数据时，其实我们只需要按部就班地执行以下3 步操作：<br>1、由于红黑树本身是一棵二叉查找树，所以在插入新的结点时，完全按照二叉查找树插入结点的方法，找到新结点插入的位置；<br>2、将新插入的结点结点初始化，颜色设置为红色后插入到指定位置；（将新结点初   始化为红色插入后，不会破坏红黑树第 5 条的性质）<br>3、由于插入新的结点，可能会破坏红黑树第 4 条的性质（若其父结点颜色为红色，就破坏了红黑树的性质），此时需要调整二叉查找树，想办法通过旋转以及修改树中结点的颜色，使其重新成为红黑树！</p></blockquote><p>第一步和第二步都比较容易，与二叉查找树差不多，最麻烦的就是第三步对树的调整。在红黑树中插入结点时，根据插入位置的不同可分为以下 3 种情况，前两种都比较简单：</p><p>第一种，插入位置为整棵树的树根。处理办法：只需要将插入结点的颜色改为黑色即可。</p><p>第二种：如果插入位置的双亲结点的颜色为黑色。处理方法：此种情况不需要做任何工作，新插入的颜色为红色的结点不会破坏红黑树的性质。</p><p>第三种情况就麻烦了，插入位置的双亲结点的颜色为红色。同样的，我们也有相对应的处理方法：因为插入结点颜色为红色，并且双亲结点也是红色的，所以破坏了红黑树第 4 条性质，那么这个时候就需要结合其祖父结点和祖父结点的另一个孩子结点（即叔叔结点）的状态，在这里我们又要分成 3 种情况来讨论：</p><p>1、当前结点的父节点是红色，且“叔叔结点”也是红色，所以破坏了红黑树的第 4 条性质。此时的解决方案就是：我们将父结点颜色改为黑色；将叔叔结点颜色改为黑色；再将祖父结点颜色改为红色；下一步将祖父结点认做当前结点，继续判断，处理结果如下图所示：<br><img src="/2022/11/12/hong-hei-shu/图21.png" alt><br>分析：此种情况下，由于父结点和当前结点颜色都是红色，所以为了不产生冲突，将父结点的颜色改为黑色。但是虽避免了破坏第 4 条，但是却导致该条路径上的黑高度增加了 1 ，破坏了第 5 条性质。但是在将祖父结点颜色改为红色、叔叔结点颜色改为黑色后，该部分子树没有破坏第 5 条性质。但是由于将祖父结点的颜色改变，还需判断是否破坏了上层树的结构，所以需要将祖父结点看做当前结点，继续判断。</p><p>2、当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的右孩子。解决方案：将父结点作为当前结点做左旋操作。<br><img src="/2022/11/12/hong-hei-shu/图22.png" alt><br>在进行以父结点为当前结点的左旋操作后，此种情况就转变成了第 3 种情况，处理过程跟第 3 种情况同步进行。</p><p>3、当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的左孩子。解决方案：将父结点颜色改为黑色，祖父结点颜色改为红色，从祖父结点处进行右旋处理。如下图所示：<br><img src="/2022/11/12/hong-hei-shu/图23.png" alt><br>分析：在此种情况下，由于当前结点 F 和父结点 S 颜色都为红色，违背了红黑树的性质 4，此时可以将 S 颜色改为黑色，又违反了性质 5，因为所有通过 S 的路径其黑高度都增加了 1 ，所以需要将其祖父结点颜色设为红色后紧接一个右旋，这样这部分子树有成为了红黑树。（上图中的右图虽看似不是红黑树，但是只是整棵树的一部分，以 S 为根结点的子树一定是一棵红黑树)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RBT_Node* Insert_BST(RBT_Node*&amp; p, RBT_Node*&amp; r, const int&amp; v)&#123;if (r &#x3D;&#x3D; nil)&#123;&#x2F;&#x2F;数为空r &#x3D; new RBT_Node(v, RED, nil, nil, p);if (p &#x3D;&#x3D; nil)&#123;root &#x3D; r;&#125;if (v &gt; p-&gt;val)  &#x2F;&#x2F;插入的节点键值小于父节点的键值&#123;p-&gt;right_Child &#x3D; r;  &#x2F;&#x2F;则该节点成为父节点右孩子&#125;else&#123;p-&gt;left_Child &#x3D; r;  &#x2F;&#x2F;则该节点成为父节点右孩子&#125;&#125;&#x2F;&#x2F;若不为空，则一直搜索直至找到空else&#123;if (v &lt; r-&gt;val)&#123;return Insert_BST(r,r-&gt;left_Child, v);  &#x2F;&#x2F;利用递归进行调用&#125;else&#123;return Insert_BST(r,r-&gt;right_Child, v);&#125;&#125;return r;&#125;&#x2F;&#x2F;插入后的调整函数void insert(const int&amp; v)&#123;RBT_Node* z &#x3D; Insert_BST(nil, root, v);&#x2F;&#x2F;首先判断其父节点颜色为红色时才需要调整；为黑色时直接插入即可，不需要调整while (z-&gt;parent-&gt;color &#x3D;&#x3D; RED)  &#x2F;&#x2F;父节点的颜色为红色&#123;&#x2F;&#x2F;由于还涉及到其叔叔节点，所以此处需分开讨论，确定父节点是祖父节点的左孩子还是右孩子if (z-&gt;parent-&gt;parent-&gt;left_Child &#x3D;&#x3D; z-&gt;parent)  &#x2F;&#x2F;父节点是左节点&#123;&#x2F;&#x2F;叔节点为红色if (z-&gt;parent-&gt;parent-&gt;right_Child-&gt;color &#x3D;&#x3D; RED)  &#123;&#x2F;*如果叔叔结节点颜色为红色，此为第 1 种情况，处理方法为：父节点颜色改为黑色；叔叔节点颜色改为黑色；祖父节点颜色改为红色，将祖父节点赋值为当前结点，继续判断；*&#x2F;z-&gt;parent-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;父节点z-&gt;parent-&gt;parent-&gt;right_Child-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;叔节点z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;  &#x2F;&#x2F;祖父节点z &#x3D; z-&gt;parent-&gt;parent;  &#125;&#x2F;*反之，如果叔叔节点颜色为黑色，此处需分为两种情况：1、当前节点是父节点的右孩子；2、当前节点是父节点的左孩子*&#x2F;else&#123;&#x2F;*当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的右孩子。解决方案：将父节点作为当前节点做左旋操作。*&#x2F;if (z-&gt;parent-&gt;right_Child &#x3D;&#x3D; z)&#123;z &#x3D; z-&gt;parent;left_rotate(z);&#125;&#x2F;*当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的左孩子。解决方案：将父节点颜色改为黑色，祖父节点颜色改为红色，从祖父节点处进行右旋处理。*&#x2F;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;right_rotate(z-&gt;parent-&gt;parent);&#125;&#125;            &#x2F;*如果父节点时祖父节点的右孩子只需将以上代码部分中的left改为right即可，道理是一样的。*&#x2F;else&#123;if (z-&gt;parent-&gt;parent-&gt;left_Child-&gt;color &#x3D;&#x3D; RED)&#123;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;z-&gt;parent-&gt;parent-&gt;left_Child-&gt;color &#x3D; BLACK;z &#x3D; z-&gt;parent-&gt;parent;&#125;else&#123;if (z-&gt;parent-&gt;left_Child &#x3D;&#x3D; z)&#123;z &#x3D; z-&gt;parent;right_rotate(z);&#125;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;left_rotate(z-&gt;parent-&gt;parent);&#125;&#125;&#125;root-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;将根节点的颜色设置为黑色&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、红黑树的删除"><a href="#6、红黑树的删除" class="headerlink" title="6、红黑树的删除"></a>6、红黑树的删除</h3><blockquote><p>删除节点要比插入节点简单一点，在红黑树中删除结点，只需要完成 2 步操作：<br>1、将红黑树按照二叉查找树删除结点的方法删除指定结点；<br>2、重新调整删除结点后的树，使之重新成为红黑树；（还是通过旋转和重新着色的方式进行调整）</p></blockquote><p>在树删除结点的时候，又要分为 3 种情况：</p><p>第一种：若该删除结点本身是叶子结点，则可以直接删除；</p><p>第二种：若只有一个孩子结点（左孩子或者右孩子），则直接让其孩子结点顶替该删除结点；</p><p>第三种：若有两个孩子结点，则找到该结点的右子树中值最小的叶子结点来顶替该结点，然后删除这个值最小的叶子结点。</p><p>以上这三种情况最终都需要删除某个结点，所以我们此时需要判断删除该结点是否会破坏红黑树的性质。判断的依据是：</p><ul><li>如果删除结点的颜色为红色，则不会破坏；</li><li>如果删除结点的颜色为黑色，则肯定会破坏红黑树的第 5 条性质，此时就需要对树进行调整，调整方案又分成4种情况讨论：</li></ul><p>1、删除结点的兄弟结点颜色是红色，调整措施为：将兄弟结点颜色改为黑色，父亲结点改为红色，以父亲结点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后兄弟结点发生了变化），如下图所示：<br><img src="/2022/11/12/hong-hei-shu/图24.png" alt><br>2、删除结点的兄弟结点及其孩子全部都是黑色的，调整措施为：将删除结点的兄弟结点设为红色，同时设置删除结点的父结点标记为新的结点，继续判断；</p><p>3、删除结点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟结点设为红色，兄弟结点的左孩子结点设为黑色，以兄弟结点为准进行右旋操作，最终更新删除结点的兄弟结点；</p><p>4、删除结点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除结点的父结点的颜色赋值给其兄弟结点，然后再设置父结点颜色为黑色，兄弟结点的右孩子结点为黑色，根据其父结点做左旋操作，最后设置替换删除结点的结点为根结点；</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void RBT_Transplant(RBT_Node*&amp; u, RBT_Node*&amp; v)&#123;    if (u-&gt;parent &#x3D;&#x3D; nil)    &#123;        root &#x3D; v;    &#125;    else if (u &#x3D;&#x3D; u-&gt;parent-&gt;left_Child)    &#123;        u-&gt;parent-&gt;left_Child &#x3D; v;    &#125;    else    &#123;        u-&gt;parent-&gt;right_Child &#x3D; v;    &#125;    v-&gt;parent &#x3D; u-&gt;parent;&#125;&#x2F;&#x2F;删除节点void Delete_RBT(RBT_Node* z)&#123;    RBT_Node* y &#x3D; z;    bool delcol &#x3D; y-&gt;color;    RBT_Node* x &#x3D; z;    &#x2F;*如果只有一个孩子结点（只有左孩子或只有右孩子），    直接用孩子结点顶替该结点位置即可（没有孩子结点的也走此判断语句）。*&#x2F;    if (z-&gt;left_Child &#x3D;&#x3D; nil)    &#123;        x &#x3D; z-&gt;right_Child;        RBT_Transplant(z, z-&gt;right_Child);    &#125;    else if (z-&gt;right_Child &#x3D;&#x3D; nil)    &#123;        x &#x3D; z-&gt;left_Child;        RBT_Transplant(z, z-&gt;left_Child);    &#125;    &#x2F;&#x2F;如果两个孩子，就找到右子树中最小的结点，将之代替，然后直接删除该结点即可    else    &#123;        y &#x3D; Find_min(z-&gt;right_Child);        delcol &#x3D; y-&gt;color;        x &#x3D; y-&gt;right_Child;        if (y-&gt;parent &#x3D;&#x3D; z)        &#123;            x-&gt;parent &#x3D; y;        &#125;        else        &#123;            RBT_Transplant(y, y-&gt;right_Child);            y-&gt;right_Child &#x3D; z-&gt;right_Child;            y-&gt;right_Child-&gt;parent &#x3D; y;        &#125;        RBT_Transplant(z, y);        y-&gt;left_Child &#x3D; z-&gt;left_Child;        y-&gt;left_Child-&gt;parent &#x3D; y;        y-&gt;color &#x3D; z-&gt;color;    &#125;    &#x2F;*在删除该结点之前，需判断此结点的颜色：如果是红色，直接删除，不会破坏红黑树；    若是黑色，删除后会破坏红黑树的第 5 条性质，需要对树做调整。*&#x2F;    if (delcol &#x3D;&#x3D; BLACK)    &#123;        Delete_Fixup_RBT(x);    &#125;&#125;void Delete_RBT(const int&amp; v)&#123;    RBT_Node* z &#x3D; Get_Node(root, v);    if (z &#x3D;&#x3D; nil)    &#123;        return;    &#125;    Delete_RBT(z);&#125;&#x2F;&#x2F;删除后调整树节点void Delete_Fixup_RBT(RBT_Node* x)&#123;    while (x !&#x3D; root &amp;&amp; x-&gt;color &#x3D;&#x3D; BLACK)    &#123;        if (x &#x3D;&#x3D; x-&gt;parent-&gt;left_Child)        &#123;            RBT_Node* w &#x3D; x-&gt;parent-&gt;right_Child;            &#x2F;*第 1 种情况：删除节点的兄弟节点颜色是红色。            解决方案为：将兄弟节点颜色改为黑色，父亲节点改为红色，以父亲节点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后 兄弟结点发生了变化）*&#x2F;            if (w-&gt;color &#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; BLACK;                x-&gt;parent-&gt;color &#x3D; RED;                left_rotate(x-&gt;parent);                w &#x3D; x-&gt;parent-&gt;right_Child;            &#125;            &#x2F;*第2种情况：删除节点的兄弟节点及其孩子全部都是黑色的。            解决方案为：将删除节点的兄弟结点设为红色，同时设置删除节点的父节点标记为新的结点，继续判断*&#x2F;            if (w-&gt;left_Child-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; w-&gt;right_Child-&gt;color&#x3D;&#x3D; BLACK)            &#123;                w-&gt;color &#x3D; RED;                x &#x3D; x-&gt;parent;            &#125;            else            &#123;                &#x2F;*第3种情况：删除节点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。                解决方案为：将兄弟节点设为红色，兄弟节点的左孩子结点设为黑色，以兄弟节点为准进行右旋操作，最终更新删除结点的兄    弟节点*&#x2F;                if (w-&gt;right_Child-&gt;color &#x3D;&#x3D; BLACK)                &#123;                    w-&gt;left_Child-&gt;color &#x3D; BLACK;                    w-&gt;color &#x3D; RED;                    right_rotate(w);                    w &#x3D; x-&gt;parent-&gt;right_Child;                &#125;                &#x2F;*第4种情况：删除节点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色）                解决方案为：将删除节点的父节点的颜色赋值给其兄弟节点，然后再设置父节点颜色为黑色，兄弟节点的右孩子节点为黑色，    根据其父节点做左旋操作，最后设置替换删除节点的结点为根结点；将删除节点的父节点的颜色赋值给其兄弟节点，然后再设    置父节点颜色为黑色，兄弟节点的右孩子节点为黑色，根据其父节点做左旋操作，最后设置替换删除节点的结点为根节点*&#x2F;                w-&gt;color &#x3D; x-&gt;parent-&gt;color;                x-&gt;parent-&gt;color &#x3D; BLACK;                w-&gt;right_Child-&gt;color &#x3D; BLACK;                left_rotate(x-&gt;parent);                x &#x3D; root;            &#125;        &#125;        else        &#123;            RBT_Node* w &#x3D; x-&gt;parent-&gt;left_Child;            if (w-&gt;color &#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; BLACK;                x-&gt;parent-&gt;color &#x3D; RED;                right_rotate(x-&gt;parent);                w &#x3D; x-&gt;parent-&gt;left_Child;            &#125;            if (w-&gt;right_Child-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; w-&gt;left_Child-&gt;color&#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; RED;                x &#x3D; x-&gt;parent;            &#125;            else            &#123;                if (w-&gt;left_Child-&gt;color &#x3D;&#x3D; BLACK)                &#123;                    w-&gt;right_Child-&gt;color &#x3D; BLACK;                    w-&gt;color &#x3D; RED;                    left_rotate(w);                    w &#x3D; x-&gt;parent-&gt;left_Child;                &#125;                w-&gt;color &#x3D; x-&gt;parent-&gt;color;                x-&gt;parent-&gt;color &#x3D; BLACK;                w-&gt;left_Child-&gt;color &#x3D; BLACK;                right_rotate(x-&gt;parent);                x &#x3D; root;            &#125;        &#125;    &#125;    x-&gt;color &#x3D; BLACK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、红黑树的应用"><a href="#6、红黑树的应用" class="headerlink" title="6、红黑树的应用"></a>6、红黑树的应用</h3><p>1、散列表的冲突处理<br>map的实现，底层一般会采用红黑树，在节点多的时候效率高。<br>在节点少的时候，可用链表方式。<br><img src="/2022/11/12/hong-hei-shu/图25.png" alt><br>2、动态插入、删除和查询较多的场景</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 2-3树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋AI（三）</title>
      <link href="/2022/09/17/wu-zi-qi-ai-san/"/>
      <url>/2022/09/17/wu-zi-qi-ai-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Min-Max算法"><a href="#一、Min-Max算法" class="headerlink" title="一、Min-Max算法"></a>一、Min-Max算法</h2><hr><blockquote><p><strong>Min-Max算法</strong>（亦称 <strong>MiniMax</strong> or <strong>MM</strong>）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。<br>Minimax算法常用于棋类等由两方较量的游戏和程序。该算法是<a href="[零和博弈（社会学概念）_百度百科 (baidu.com">零和博弈</a>](<a href="https://baike.baidu.com/item/零和博弈/3562463))，即两个玩家进行游戏，如果其中一方得到利益那么另一方就会失去利益，游戏利益的总和为0（某些情况下为常数）。简单来说，就是让最不利的情况所造成的影响最小化。很多棋类游戏都可以采用这一种算法。因为我实现的AI是五子棋，这里我以五子棋进行说明。">https://baike.baidu.com/item/零和博弈/3562463))，即两个玩家进行游戏，如果其中一方得到利益那么另一方就会失去利益，游戏利益的总和为0（某些情况下为常数）。简单来说，就是让最不利的情况所造成的影响最小化。很多棋类游戏都可以采用这一种算法。因为我实现的AI是五子棋，这里我以五子棋进行说明。</a></p></blockquote><hr><p>首先要介绍一下博弈树的概念：五子棋看起来有各种各样的走法，但如果把每一步的走法展开，就是一颗巨大的博弈树。博弈树就是己方和敌方分别进行决策时形成的树状结构，每一个节点的分支表示当前节点可以走的各种可能的位置，每一个叶子节点表示一个局面。然后从根节点为0开始，再假设奇数层代表的是AI可能的走法，偶数层则表示玩家可能的走法。如果AI先手进行的话，那么第一层就是电脑的所有可能的走法，第二层就是玩家的所有可能走法，以此类推。假设从空棋盘开始（根节点），AI进行落子，那么就有15x15=255种落子选择，接着落子完之后，形成的是一颗有255个节点的博弈树，博弈树的叶子节点就是一个局面。此时玩家进行落子，玩家有254种选择，那么新形成的博弈树就会有<strong>255x254</strong>个叶子结点。</p><p>我们再来看看博弈树每一层的节点个数有多少？如果平均分支为a（平均每一步有a种可能的走法），博弈树层数为d（也就是常说的树的深度），根节点为第0层，那么叶子节点的总数约为$a^d$，因此，我们发现<strong>博弈树是指数级别的</strong>。</p><p>暂且不考虑这么多个节点需要多久能算出来。</p><p>对博弈树的基本认识以后，我们再来实现实现AI。AI的实现很简单，只要有点搜索算法的基础，我们就可以知道应该先遍历博弈树的所有叶子结点，然后寻找到对AI最有利的局面，最后进行落子。那么如何才能知道哪一个分支的走法是最优的，所以就需要用到上一篇文章（<a href="http://ude123456.top/2022/09/13/wu-zi-qi-ai-er/">五子棋AI（二） </a>）提到的评估函数，对当前整个局势作出一个基本的评估，然后对当前棋盘局势进行打分，返回一个分数。在博弈树中，当AI走棋时选择对自己最有利的位置节点走，而当玩家走棋时，是AI模拟玩家选择对玩家最有利的位置节点走。我们规定对AI越有利，分数越大，对玩家越有利，分数越小。 </p><p>我们遍历这颗博弈树的时候就很明显知道该如何选择分支了：</p><p>AI走棋的层我们称为 MAX层，这一层AI要保证自己利益最大化，那么就需要选取分数最高的节点。<br>玩家走棋的层我们称为MIN层，这一层玩家要保证自己的利益最大化，那么就会选取分数最低的节点。<br><img src="/2022/09/17/wu-zi-qi-ai-san/图1.png" alt><br>可以看到上图种分为了max层和min层，在max层总是取最大值，在min层总是取最小值。</p><p>而每一个节点的分数，都是由子节点决定的，因此我们对博弈树只能进行深度优先搜索而无法进行广度优先搜索。所以Min-Max算法也是一种深度优先搜索算法。</p><p>现在我们来分析一下Min-Max算法与最基本的深度优先搜索有什么区别：<br>为了方便讲解，我们先规定A即为AI下棋，B为玩家下棋。设先手为A，后手为B；那么A为max局面，B为min局面。上图中A一开始有 2 种走法（ $W2$ 和 $W3$），它走 $W2$ 还是 $W3$ 取决于 $W2$ 和 $W3$ 的估值函数值（假定其为$f(x)$），因为 A 是 max 局面，所以它会取 $f(W2)$ 和 $f(W3)$ 中大的那个， $f(W2)$ 和 $f(W3)$求呢？通常是以递归的方式对博弈树进行搜索，我们通常可以设定叶子结点局面的估价值。</p><p>我们以$W1 \rightarrow W3$为例，上图的搜索过程为 $W1 \rightarrow W3 \rightarrow W6 \rightarrow W11 \rightarrow W18$ ，然后回溯到 $W1 \rightarrow W3\rightarrow W6 \rightarrow W11$ 得到 $f(W11) = 7$ ，接着 $W1 \rightarrow W3 \rightarrow W6 \rightarrow W11 \rightarrow W19$ 得到  $f’(W11) = 5$，$W11$ 在第四层，是 min 局面，所以它会选择得到的结果中比较小的那个，就是用 $f’(W11)$ 替代 $f(W11)$ ，即 $f(W11) = 5$，接着 $W1 \rightarrow W3 \rightarrow W6 \rightarrow W12 \rightarrow W20$ 得到 $f(W20) = - \infty$，然后再回溯到 $W1 \rightarrow W3 \rightarrow W6 \rightarrow W12$ 得到$f(W12)=-\infty$。再继续往前回溯到 $W1 \rightarrow W3 \rightarrow W6$，因为 $W6$ 在第三层，是max局面，所以它会选择得到的结果中最大的那个，$f(W11)&gt;f(W12)$，所以 $f(W6)=5$ 。以此不断类推，则最后得到 $f(W1)=-7$ 。</p><hr><blockquote><p>Min-Max算法的思想非常简单，但是现在我们又发现一个问题：就是我们建立起来的博弈树十分庞大，是一颗非常庞大的二叉树，如果我们依靠暴力搜索来寻找最佳的解法，那无疑是十分耗费时间的，运行效率也十分低下。因此现在我们需要用到一些剪枝手段，常用的比较初级的有 $\alpha\beta$ 剪枝。</p><hr></blockquote><h2 id="二、αβ剪枝算法"><a href="#二、αβ剪枝算法" class="headerlink" title="二、αβ剪枝算法"></a>二、αβ剪枝算法</h2><hr><blockquote><p>αβ剪枝是一种搜索算法，用以减少Min-Max算法搜索树的节点数，以提高运算速度。当算法评估出某策略的后续走法比之前策略的还差时，就会停止计算该策略的后续发展。它基本的原理是：</p><ul><li>当一个 Min 节点的 β值≤任何一个父节点的α值时 ，剪掉该节点的所有子节点</li><li>当一个 Max 节点的 α值≥任何一个父节点的β值时 ，剪掉该节点的所有子节点</li></ul></blockquote><hr><p>我们具体来看一个例子</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五子棋AI </tag>
            
            <tag> 博弈树 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Min-Max算法 </tag>
            
            <tag> αβ剪枝算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋AI（二）</title>
      <link href="/2022/09/13/wu-zi-qi-ai-er/"/>
      <url>/2022/09/13/wu-zi-qi-ai-er/</url>
      
        <content type="html"><![CDATA[<h2 id="1、实现AI走棋"><a href="#1、实现AI走棋" class="headerlink" title="1、实现AI走棋"></a>1、实现AI走棋</h2><h3 id="1-1-设计AI的数据成员"><a href="#1-1-设计AI的数据成员" class="headerlink" title="1.1　设计AI的数据成员"></a>1.1　设计AI的数据成员</h3><hr><blockquote><ul><li>添加棋盘数据成员，以表示对哪个棋盘下棋。</li><li>添加评分数组chess[MAX_BORDER][MAX_BORDER]， 用来存储AI对棋盘所有落点的价值评估。</li></ul><hr><p>AI.h</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:Chess* ch;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再添加评分数组,为防止二次定义，我们使用extern关键词进行规避该风险。</p><p>chess.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">extern int chess[MAX_BORDER][MAX_BORDER];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-对AI进行初始化"><a href="#1-2-对AI进行初始化" class="headerlink" title="1.2　对AI进行初始化"></a>1.2　对AI进行初始化</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;AI初始化void AI::Init(Chess* chess)&#123;this-&gt;ch &#x3D; chess;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、评估函数"><a href="#2、评估函数" class="headerlink" title="2、评估函数"></a>2、评估函数</h2><blockquote><p>对于五子棋AI而言，最重要的就是它的评估函数。评估函数网上大概有两种，但是很多人会弄混淆。</p><ul><li><p>第一种函数暂且命名为Current函数（只是一个代号，与第二种相区别），它是对一个可走的空位子进行打分，如果AI将棋子落在这个空位置的分数越高，说明这个位置就越好，每次AI走棋就找到一个最好的空位置就行了。</p></li><li><p>第二种函数称为Global函数，是对现在的棋盘局面进行打分。 AI棋子首先找所有可以走的空位置，模拟走了这个位置以后，用Global函数进行局面评分，如果走了这样的一个空位置的得分越高，说明这个位置就越好，每次AI走棋就找这样一个分数最高的位置。</p></li></ul><p><font color="red">这两个评估函数的区别非常大！</font>如果你只是想实现一个只看一步的AI，那么你可以用Current函数也可以用Global函数。但是如果你想要实现基于博弈树的Min-Max算法和α-β剪枝算法的AI，就只能用Global函数，因为AI必须要对局面打分，而不是对位置打分。</p></blockquote><p>对局势的判断要怎样做才会有个准确的估计呢？其实<strong>五子棋的局势无非就是对棋型个数和权重的统计。</strong></p><h3 id="2-1-五子棋基本棋型介绍"><a href="#2-1-五子棋基本棋型介绍" class="headerlink" title="2.1　五子棋基本棋型介绍"></a>2.1　五子棋基本棋型介绍</h3><p>最常见的基本棋型有以下几种：连五，活四，冲四，活三，眠三，活二，眠二。<br>具体可参考：<a href="http://game.onegreen.net/wzq/HTML/142336.html">http://game.onegreen.net/wzq/HTML/142336.html</a></p><p>① <strong>连五</strong>：顾名思义，五颗同色棋子连在一起，不需要多讲。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图1.jpg" alt="图1">　　　　　　　<br>②<strong>活四</strong>：有两个连五点（即有两个点可以形成五），图中白点即为连五点。<br>稍微思考一下就能发现活四出现的时候，如果对方单纯过来防守的话，是已经无法阻止自己连五了<br><img src="/2022/09/13/wu-zi-qi-ai-er/图2.jpg" alt="图1"><br>③<strong>冲四</strong>：有一个连五点，如下面三图，均为冲四棋型。图中白点为连五点。<br>相对比活四来说，冲四的威胁性就小了很多，因为这个时候，对方只要跟着防守在那个唯一的连五点上，冲四就没法形成连五。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图3.jpg" alt="图3">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图4.jpg" alt="图4">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图5.jpg" alt="图5">　　　　　　　　<br>④<strong>活三</strong>：可以形成活四的三，如下图，代表两种最基本的活三棋型。图中白点为活四点。<br>活三棋型是我们进攻中最常见的一种，因为活三之后，如果对方不以理会，将可以下一手将活三变成活四，而我们知道活四是已经无法单纯防守住了。所以，当我们面对活三的时候，需要非常谨慎对待。在自己没有更好的进攻手段的情况下，需要对其进行防守，以防止其形成可怕的活四棋型。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图6.jpg" alt="图6">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图7.jpg" alt="图7"><br>其中图7中间跳着一格的活三，也可以叫做跳活三。</p><p>⑤<strong>眠三</strong>：只能够形成冲四的三，如下各图，分别代表最基础的六种眠三形状。图中白点代表冲四点。眠三的棋型与活三的棋型相比，危险系数下降不少，因为眠三棋型即使不去防守，下一手它也只能形成冲四，而对于单纯的冲四棋型，我们知道，是可以防守住的。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图8.jpg" alt="图8">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图9.jpg" alt="图9">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图10.jpg" alt="图10"></p><p><img src="/2022/09/13/wu-zi-qi-ai-er/图11.jpg" alt="图11">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图12.jpg" alt="图12">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图13.jpg" alt="图13">　　　　<br>如上所示，眠三的形状是很丰富的。对于初学者，在下棋过程中，很容易忽略不常见的眠三形状，例如图2-13所示的眠三。<br>有新手学了活三眠三后，会提出疑问，说活三也可以形成冲四啊，那岂不是也可以叫眠三？<br>会提出这个问题，说明对眠三定义看得不够仔细：眠三的的定义是，只能够形成冲四的三。而活三可以形成眠三，但也能够形成活四。<br>此外，在五子棋中，活四棋型比冲四棋型具有更大的优势，所以，我们在既能够形成活四又能够形成冲四时，会选择形成活四。</p><p>⑥<strong>活二</strong>：能够形成活三的二，如下图，是三种基本的活二棋型。图中白点为活三点。<br>活二棋型看起来似乎很无害，因为他下一手棋才能形成活三，等形成活三，我们再防守也不迟。但其实活二棋型是非常重要的，尤其是在开局阶段，我们形成较多的活二棋型的话，当我们将活二变成活三时，才能够令自己的活三绵绵不绝微风里，让对手防不胜防。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图14.jpg" alt="图14">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图15.jpg" alt="图15">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图16.jpg" alt="图16">　　</p><p>⑦<strong>眠二</strong>：能够形成眠三的二。图中四个为最基本的眠二棋型，细心且喜欢思考的同学会根据眠三介绍中的图2-13找到与下列四个基本眠二棋型都不一样的眠二。图中白点为眠三点。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图17.jpg" alt="图17">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图18.jpg" alt="图18"></p><p><img src="/2022/09/13/wu-zi-qi-ai-er/图19.jpg" alt="图19">　　<img src="/2022/09/13/wu-zi-qi-ai-er/图20.jpg" alt="图20"></p><p>⑧<strong>活一</strong>：走一步可以形成活2。</p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2　评估方法"></a>2.2　评估方法</h3><p>对整个棋盘进行遍历，对于每一个白棋或黑棋，以它为中心，记录符合的棋型个数。</p><p>具体实现方式如下：<br>1、遍历棋盘上的每个点，如果是黑棋或白旗，则对这个点所在四个方向形成的四条线分别进行评估。四个方向即水平，竖直，两个斜线( \ , / ），四个方向依次按照从左到右， 从上到下，从左上到右下，从左下到右上来检测。</p><p>2、对于具体的一条线，如下图，已选取点为中心，取该方向上前面两个点，后面两个点，组成一个长度为4的“数组”（实际上是转换成二进制）。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图21.png" alt><br>然后找出和中心点相连的同色棋子有几个，比如下图，相连的白色棋子有3个，根据相连棋子的个数再分别进行判断，最后得出这行属于上面说的哪一种棋型。<br><img src="/2022/09/13/wu-zi-qi-ai-er/图22.png" alt><br>这里有个注意点，在评估白旗1的时候，白棋3和5已经被判断过，所以要标记下，下次遍历到这个方向的白棋3和5，需要跳过，避免重复统计棋型。</p><p>3、根据棋盘上黑棋和白棋的棋型统计信息，按照一定规则进行评分。<br>假设形成该棋局的最后一步是黑棋下的，则最后的评分是（黑棋得分 - 白棋得分），在相同棋型相同个数的情况下，白棋会占优，因为下一步是白棋下。比如黑棋有个冲四，白棋有个冲四，显然白棋占优，因为下一步白棋就能成连五。</p><p>这里的权重设计是有技巧的，因为很多大佬已经经过实验得出许多不同的权重参数，所以这里我就直接使用大佬们给出的数据了。（下标中的死棋其实有的可以看成是活棋或者冲棋，但是为了方便就直接看作死棋的一种）</p><div class="table-container"><table><thead><tr><th style="text-align:center">棋型代号</th><th style="text-align:center">棋型说明</th><th style="text-align:center">权重</th></tr></thead><tbody><tr><td style="text-align:center">VALUE_WIN</td><td style="text-align:center">长连</td><td style="text-align:center">10000000</td></tr><tr><td style="text-align:center">VALUE_Huo4</td><td style="text-align:center">活四</td><td style="text-align:center">150000</td></tr><tr><td style="text-align:center">VALUE_Chong4</td><td style="text-align:center">冲四</td><td style="text-align:center">7500</td></tr><tr><td style="text-align:center">VALUE_Si4</td><td style="text-align:center">死四</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">VALUE_Huo3</td><td style="text-align:center">活三</td><td style="text-align:center">7500</td></tr><tr><td style="text-align:center">VALUE_Chong3</td><td style="text-align:center">冲三</td><td style="text-align:center">2000</td></tr><tr><td style="text-align:center">VALUE_Si3</td><td style="text-align:center">死三</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">VALUE_Huo2</td><td style="text-align:center">活二</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">VALUE_Chong2</td><td style="text-align:center">冲二</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">VALUE_Si2</td><td style="text-align:center">死二</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">VALUE_Huo1</td><td style="text-align:center">活一</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">VALUE_Chong1</td><td style="text-align:center">冲一</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">VALUE_Si1</td><td style="text-align:center">死一</td><td style="text-align:center">0</td></tr></tbody></table></div><p>另外这里我在下面给出一位大佬给出的权重设计规则（但跟我给出的权重设计不相同），有兴趣的可以自行了解。具体的可参考：<a href="https://blog.csdn.net/livingsu/article/details/104539741">(250条消息) 五子棋ai：极大极小搜索和α-β剪枝算法的思想和实现(qt和c++)（二）贪心算法和评估函数_livingsu的博客-CSDN博客</a></p><blockquote><ul><li>规则一：己方棋型权重为正，对方棋型权重为负，且相同棋型时，对方权重的绝对值要大于己方(可以设置为2倍或者3倍关系)。这是因为要考虑到进攻和防守，现在是己方(ai白子)下，例如：如果己方走了一步棋形成了活2，而对方已经有一个活2，那么显然是对方占优一些，因为下一步是对方走，对方是可以形成更高等级的活3的，所以己方活2就没有对方活2等级高。</li><li>规则2：等级：连5&gt;活4&gt;冲4=活3&gt;眠3=活2&gt;眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍）。这是因为会重复计算等级比较低的棋型，为了不影响总体判断，比如一开始放一个子，活1的权重会计算16次，我设置为20倍，那么活2的权重刚好比16倍活1还要大一些。</li><li>规则3：对方连5、对方活4、对方冲4、对方活3的绝对值要设置大一点，这一点非常重要！！如果此时对方已经连五，说明己方已经输了。如果此时对方有活4和冲4，那么如果己方没有连5的话，己方必须要去阻止对方的活4和冲4。像这样可以分析出其他棋型权重。</li></ul></blockquote><p>根据上述的步骤就可以设计评估函数了。</p><h4 id="2-2-1-对棋形分数进行记录"><a href="#2-2-1-对棋形分数进行记录" class="headerlink" title="2.2.1　对棋形分数进行记录"></a>2.2.1　对棋形分数进行记录</h4><p>AI.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;棋形分数#define INF 0x3f3f3f3f    &#x2F;&#x2F;定义无穷大#define VALUE_WIN10000000&#x2F;&#x2F;长连&#x2F;成五 获胜#define VALUE_Huo4150000&#x2F;&#x2F;活四#define VALUE_Chong47500&#x2F;&#x2F;冲四#define VALUE_Si4    20&#x2F;&#x2F;死四#define VALUE_Huo3  7500&#x2F;&#x2F;活三#define VALUE_Chong3  2000&#x2F;&#x2F;冲三#define VALUE_Si3  10&#x2F;&#x2F;死三#define VALUE_Huo2  1000 &#x2F;&#x2F;活二#define VALUE_Chong2  200 &#x2F;&#x2F;冲二#define VALUE_Si2  5&#x2F;&#x2F;死二#define VALUE_Huo1  100 &#x2F;&#x2F;活一#define VALUE_Chong1  50 &#x2F;&#x2F;冲一#define VALUE_Si1  0&#x2F;&#x2F;死一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-对下棋的四个方向进行估分"><a href="#2-2-2-对下棋的四个方向进行估分" class="headerlink" title="2.2.2　对下棋的四个方向进行估分"></a>2.2.2　对下棋的四个方向进行估分</h4><p>现在有8种有效的棋型（连五，活四，冲四，活三，眠三，活二，眠二，活一），大部份资料都是黑棋白棋用两个五元数组或者六元数组来存储，因为我只用结构体来区分，将黑棋和白棋分开算（<strong>side</strong>就是区分黑棋和白棋的结构体），并且在对下棋位置的四个位置估分时只关注当前AI的棋色，而不关注棋手下的棋和无棋的位置，所以，操作起来更加方便。</p><p>相关变量命名如下：</p><p>AI.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int score;int cmid, cleft, cright, cnt, leftmid, midright;int left1, left2, right1, right2;int flag;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><font color="blue">注意：上述变量是AI.cpp中的**全局变量**</font></blockquote><p>主体函数：</p><p>AI.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;对下棋位置的四个方向（|  -  \  &#x2F;）估分（准确来说应该是一个棋子的八个方向）int AI::Get_Four_Side_Score(const Chess_Position&amp; position, Object side)&#x2F;&#x2F;side指明当前位置是黑棋还是白棋&#123;score &#x3D; 0;int row, col, i; for (i &#x3D; 0; i &lt; 4; ++i) &#123;cmid &#x3D; cleft &#x3D; cright &#x3D; 0;left1 &#x3D; left2 &#x3D; right1 &#x3D; right2 &#x3D; 0;&#x2F;&#x2F;四个方向|  -  \  &#x2F;for (row &#x3D; position.row + dir[i][0], col &#x3D; position.col + dir[i][1]; chess[row][col] &#x3D;&#x3D; side; ++cmid) &#123;row +&#x3D; dir[i][0];col +&#x3D; dir[i][1];&#125;left1 &#x3D; chess[row][col] !&#x3D; EMPTY;  &#x2F;&#x2F;找到与side相同的棋子，则赋值为1&#x2F;&#x2F;若在该方向上有同side一样的棋色，则继续搜索if (left1) &#123;for (row +&#x3D; dir[i][0], col +&#x3D; dir[i][1]; chess[row][col] &#x3D;&#x3D; side; ++cleft) &#123;row +&#x3D; dir[i][0];col +&#x3D; dir[i][1];&#125;left2 &#x3D; chess[row][col] !&#x3D; EMPTY; &#x2F;&#x2F;不等于0证明有棋子，则赋值给left2&#x3D;1记录该位置已有棋子&#125;for (row &#x3D; position.row - dir[i][0], col &#x3D; position.col - dir[i][1]; chess[row][col] &#x3D;&#x3D; side; ++cmid) &#123;row -&#x3D; dir[i][0];col -&#x3D; dir[i][1];&#125;right1 &#x3D; chess[row][col] !&#x3D; EMPTY;if (right1) &#123;for (row -&#x3D; dir[i][0], col -&#x3D; dir[i][1]; chess[row][col] &#x3D;&#x3D; side; ++cright) &#123;row -&#x3D; dir[i][0];col -&#x3D; dir[i][1];&#125;right2 &#x3D; chess[row][col] !&#x3D; EMPTY;&#125;score +&#x3D; Return_A_Side_Score();  &#x2F;&#x2F;计算某个方向的分数分数&#125;return score;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码块中有一个变成小技巧可以注意一下：</p><blockquote><p>++i 和 i++的结果是一样的， 都要等代码块执行完毕才能执行语句3 ，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：. i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能.</p></blockquote><h4 id="2-2-3-计算返回某个方向的估分"><a href="#2-2-3-计算返回某个方向的估分" class="headerlink" title="2.2.3　计算返回某个方向的估分"></a>2.2.3　计算返回某个方向的估分</h4><p>我们将当前棋子的四个方向遍历以后就需要对某一个方向上的棋型进行统计分数了。</p><p>我们先用一个数组来存储四个方向：</p><p>AI.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const int dir[4][2] &#x3D; &#123; &#123;-1,0&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,1&#125; &#125;;&#x2F;&#x2F;四个方向|  -  \  &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再用三个数组分别存储活棋、冲棋和死棋的分数：</p><p>AI.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const int live[6] &#x3D; &#123; 0,VALUE_Huo1,VALUE_Huo2,VALUE_Huo3,VALUE_Huo4,VALUE_WIN &#125;;&#x2F;&#x2F;活棋分数const int go[6] &#x3D; &#123; 0,VALUE_Chong1,VALUE_Chong2,VALUE_Chong3,VALUE_Chong4,VALUE_Chong4 &#125;;&#x2F;&#x2F;冲棋分数const int death[6] &#x3D; &#123; 0, VALUE_Si1,VALUE_Si2,VALUE_Si3,VALUE_Si4,VALUE_Si4 &#125;;&#x2F;&#x2F;死棋分数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后进行估分：</p><p>AI.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;计算返回某个方向的估分int AI::Return_A_Side_Score()&#123;cmid &#x3D; min(cmid + 1, 5);if (cmid &#x3D;&#x3D; 5)return VALUE_WIN;  &#x2F;&#x2F;一个方向上已经有五个子则直接输出cnt &#x3D; min(cmid + cleft + cright, 5);leftmid &#x3D; min(cleft + cmid, 5);midright &#x3D; min(cmid + cright, 5);&#x2F;&#x2F;将四个位置的1分开，就类似将棋型数据储存进一个四元数组&#x2F;&#x2F;所以将记录的值进行二进制转换并进行一定程度的位置偏移(&quot;&lt;&lt;&quot;是左移运算符)flag &#x3D; left2 &lt;&lt; 3 | left1 &lt;&lt; 2 | right1 &lt;&lt; 1 | right2;  &#x2F;&#x2F;用二进制的0和1来代表黑棋白棋switch (flag) &#123;case 0b0000:return live[cnt];case 0b0001:case 0b1000:return max(live[leftmid], go[cnt]);case 0b0010:case 0b0011:return go[leftmid];case 0b0100:case 0b1100:return go[midright];case 0b0101:case 0b1101:return midright &gt;&#x3D; 4 ? go[midright] : death[midright];case 0b1010:case 0b1011:return leftmid &gt;&#x3D; 4 ? go[leftmid] : death[leftmid];case 0b0110:case 0b0111:case 0b1110:case 0b1111:return death[cmid];case 0b1001:return cnt &gt;&#x3D; 4 ? max(live[cmid], go[cnt]) : death[cnt];&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>“&lt;&lt;”是<font color="red">左移运算符</font>，“|”是二级制的<font color="red">异或运算符</font>，具体可参考：<a href="https://www.runoob.com/cplusplus/cpp-operators.html">C++ 运算符 | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="2-2-4-对当前整个棋盘进行评估"><a href="#2-2-4-对当前整个棋盘进行评估" class="headerlink" title="2.2.4　对当前整个棋盘进行评估"></a>2.2.4　对当前整个棋盘进行评估</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;对当前状态整个棋盘估分int AI::Evaluate_WholeChess(Object side)&#123;int returnValue &#x3D; 0;int v1 &#x3D; 0, v2 &#x3D; 0;for (int i &#x3D; TOP; i &lt;&#x3D; DOWN; ++i)for (int j &#x3D; LEFT; j &lt;&#x3D; RIGHT; ++j)if (chess[i][j] &#x3D;&#x3D; side)v1 +&#x3D; Get_Four_Side_Score(Chess_Position(i, j), side);else if (chess[i][j] !&#x3D; EMPTY) &#123;v2 +&#x3D; Get_Four_Side_Score(Chess_Position(i, j), (Object)chess[i][j]);&#125;return (int)(v1 - v2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-5-细节补充"><a href="#2-2-5-细节补充" class="headerlink" title="2.2.5　细节补充"></a>2.2.5　细节补充</h4><p>在AI.h中补充函数定义</p><p>AI.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include&lt;vector&gt;#include&quot;Chess.h&quot;using namespace std;class AI&#123;public:&#x2F;&#x2F;AI初始化void Init(Chess* chess);&#x2F;&#x2F;AI下棋接口void AISearch(Object aiSide, Chess_Position&amp; Position, Chess_Position&amp; nextPosition);        &#x2F;&#x2F;对下棋位置的四个方向估分int Get_Four_Side_Score(const Chess_Position&amp; Position, Object side);&#x2F;&#x2F;计算返回某个方向的估分int Return_A_Side_Score();&#x2F;&#x2F;对当前状态整个棋盘估分int Evaluate_WholeChess(Object side);        &#x2F;&#x2F;判断某一方是否取胜bool Is_Win(const Chess_Position Position, Object side);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，我们第二部分的评估函数已经实现完了，接下来才是真正涉及到了AI部分的算法。下一篇就是五子棋AI当中两个主要算法：Min-Max算法和αβ剪枝算法的实现。</p><p>下一篇：<a href="http://ude123456.top/2022/09/17/wu-zi-qi-ai-san/">五子棋AI（三）</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五子棋AI </tag>
            
            <tag> 博弈树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋AI（一）</title>
      <link href="/2022/09/08/wu-zi-qi-ai-yi/"/>
      <url>/2022/09/08/wu-zi-qi-ai-yi/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>一时心血来潮对棋类博弈产生了兴趣，就想着通过实现一个五子棋AI顺便了解一下相关算法和知识。</p><p>五子棋在英文中又称Gobang。先简单介绍一下，由于五子棋已经被机器严格证明了是一种“不公平”的游戏，先手黑子是绝对占优的，并且先手有必胜的套路。由于先手必胜，必须对先手进行一定的规则限制，于是就出现了“禁手”一说，即某些位置<a href="[五子棋（两人对弈的策略型棋类游戏）_百度百科 (baidu.com">（比如能形成双活3、活3冲4）</a>](<a href="https://baike.baidu.com/item/五子棋/130266))黑子不能下，不然就算黑子输。在日本，五子棋的理论得到极大发展，有禁手规则的五子棋被称为“连珠”（renju），而一般无禁手规则的叫做gomoku。由于大部分普通人下五子棋只是图一个乐趣，并不需要深入研究其中的理论规则，所以反而是gomoku在学生之间非常流行（我高中时下课就经常和同学玩五子棋）。">https://baike.baidu.com/item/五子棋/130266))黑子不能下，不然就算黑子输。在日本，五子棋的理论得到极大发展，有禁手规则的五子棋被称为“连珠”（renju），而一般无禁手规则的叫做gomoku。由于大部分普通人下五子棋只是图一个乐趣，并不需要深入研究其中的理论规则，所以反而是gomoku在学生之间非常流行（我高中时下课就经常和同学玩五子棋）。</a></p><p>这里我实现的五子棋AI是无禁手规则的（因为有禁手的太复杂，另外本人比较懒。。。），标准棋盘大小为15$\times$15，我的目的是想实现一个能打败大部分普通人的AI，因此并没有进行更深入的专业性研究。所以，如果你能战胜我实现的AI，也不用太过惊讶。</p></blockquote><hr><h3 id="1、设计项目主体框架"><a href="#1、设计项目主体框架" class="headerlink" title="1、设计项目主体框架"></a>1、设计项目主体框架</h3><p>首先先进行整体框架的设计，不写过程，直接写需要几个类！<br><img src="/2022/09/08/wu-zi-qi-ai-yi/图1.png" alt><br>这里，我设计了4个类，分别表示棋手，AI, 棋盘，游戏控制。</p><h3 id="2、给类添加主要接口"><a href="#2、给类添加主要接口" class="headerlink" title="2、给类添加主要接口"></a>2、给类添加主要接口</h3><h4 id="2-1-设计棋盘类Chess的主要接口"><a href="#2-1-设计棋盘类Chess的主要接口" class="headerlink" title="2.1　设计棋盘类Chess的主要接口"></a>2.1　设计棋盘类Chess的主要接口</h4><p>Chess.h<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once#define LEFT 5&#x2F;&#x2F;棋盘左边界#define TOP 5&#x2F;&#x2F;棋盘上边界#define RIGHT 19&#x2F;&#x2F;棋盘右边界#define DOWN 19&#x2F;&#x2F;棋盘下边界#define MAX_BORDER 25&#x2F;&#x2F;棋盘存储大小#define CHESS_SIZE 15&#x2F;&#x2F;棋盘最大网格数#define GRID_SIZE 30  &#x2F;&#x2F;网格尺寸#define WIDTH GRID_SIZE*(CHESS_SIZE+1)  &#x2F;&#x2F;网格宽度#define HEIGHT GRID_SIZE*(CHESS_SIZE+1)  &#x2F;&#x2F;网格高度#define MOUSE_P1 10#define MOUSE_P2 20#define MOUSE_COLOR LIGHTGRAY  &#x2F;&#x2F;鼠标颜色#define BACKGROUND_COLOR DARKGRAY  &#x2F;&#x2F;背景颜色&#x2F;&#x2F;十六进制表示颜色#define BLACK_CHESS_COLOR 0  &#x2F;&#x2F;黑棋颜色#define WHITE_CHESS_COLOR 0xFFFFFF  &#x2F;&#x2F;白棋颜色&#x2F;&#x2F;定义下棋对象typedef enum &#123;    EMPTY &#x3D; 0,    Black_Chess &#x3D; 1,  &#x2F;&#x2F;黑棋    White_Chess &#x3D; 2   &#x2F;&#x2F;白棋&#125; Object;&#x2F;&#x2F;下棋步数定义class Chess_Position &#123;public:int row;int col;Chess_Position(int r &#x3D; 0, int c &#x3D; 0):row(r), col(c) &#123;&#125;;&#125;;class Chess&#123;public:&#x2F;&#x2F;画出棋盘网格void Draw_ChessBoard();&#x2F;&#x2F;显示双方各自执棋情况提示void Show_Side_ChessColor(Object  humanSide);&#x2F;&#x2F;初始化棋盘网络void Init_Chess(Object  humanSide);&#x2F;&#x2F;指定位置画出一颗棋子void Show_A_Chess(int x, int y, int color);&#x2F;&#x2F;显示会话void Show_Dialog(char* dialog);&#x2F;&#x2F;显示博弈结果void Show_Result(bool humanWin);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="2-2-设计AI类的主要接口"><a href="#2-2-设计AI类的主要接口" class="headerlink" title="2.2　设计AI类的主要接口"></a>2.2　设计AI类的主要接口</h4><p>AI.h<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once#include&lt;vector&gt;#include&quot;Chess.h&quot;using namespace std;class AI&#123;public:&#x2F;&#x2F;AI初始化void Init(Chess* chess);&#x2F;&#x2F;AI下棋接口void AISearch(Object aiSide, Chess_Position&amp; Position, Chess_Position&amp; nextPosition);        &#x2F;&#x2F;判断某一方是否取胜bool Is_Win(const Chess_Position Position, Object side);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><font color="Blue">注意</font>：在最初开发时<font color="red">AISearch()</font>和<font color="red">Is_Win()</font>我并未输入参数，因为设计时并不知道要使用多少参数，这里为了方便我就直接复制进来了。</p><h4 id="2-3-设计Man类的主要接口"><a href="#2-3-设计Man类的主要接口" class="headerlink" title="2.3　设计Man类的主要接口"></a>2.3　设计Man类的主要接口</h4><p>Man.h<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once#include &quot;Chess.h&quot;class Man&#123;public:&#x2F;&#x2F;初始化void Init(Chess* chess);&#x2F;&#x2F;显示鼠标位置void Show_Mouse(int x, int y, int color);&#x2F;&#x2F;移动鼠标时更新界面void Move_Mouse(int x, int y, int nx, int ny);&#x2F;&#x2F;棋手下棋接口void human_go(Chess_Position&amp; Position, Object side);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="2-4-设计ChessGame的主要接口"><a href="#2-4-设计ChessGame的主要接口" class="headerlink" title="2.4　设计ChessGame的主要接口"></a>2.4　设计ChessGame的主要接口</h4><p>ChessGame.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include&quot;Man.h&quot;#include&quot;AI.h&quot;#include&quot;Chess.h&quot;&#x2F;&#x2F;控制AI执黑棋还是执白棋的按钮&#x2F;&#x2F;可以调节#define compSide 0&#x2F;&#x2F;0：AI为黑1：AI为白class ChessGame&#123;public:&#x2F;&#x2F;下棋接口void play();  &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-添加各个接口的具体实现"><a href="#2-5-添加各个接口的具体实现" class="headerlink" title="2.5　添加各个接口的具体实现"></a>2.5　添加各个接口的具体实现</h4><p>可以使用如下方式自动生成各接口的具体实现。先不用考虑各个接口的真正实现，直接使用空函数体代替。<br><img src="/2022/09/08/wu-zi-qi-ai-yi/图2.png" alt></p><h3 id="3、绘制界面"><a href="#3、绘制界面" class="headerlink" title="3、绘制界面"></a>3、绘制界面</h3><hr><blockquote><p>这里绘制界面用到的是C++的图形库<a href="https://easyx.cn/">EasyX </a>，需要自行安装才能使用。</p></blockquote><hr><h4 id="3-1-画出棋盘网络并进行初始化"><a href="#3-1-画出棋盘网络并进行初始化" class="headerlink" title="3.1　画出棋盘网络并进行初始化"></a>3.1　画出棋盘网络并进行初始化</h4><p>Chess.cpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;画出棋盘网格void Chess::Draw_ChessBoard()&#123;for (int i &#x3D; 1; i &lt;&#x3D; CHESS_SIZE; ++i)line(GRID_SIZE, i * GRID_SIZE, CHESS_SIZE * GRID_SIZE, i * GRID_SIZE);for (int i &#x3D; 1; i &lt;&#x3D; CHESS_SIZE; ++i)line(i * GRID_SIZE, GRID_SIZE, i * GRID_SIZE, CHESS_SIZE * GRID_SIZE);&#125;&#x2F;&#x2F;初始化棋盘网络void Chess::Init_Chess(Object humanSide)&#123;initgraph(WIDTH, HEIGHT);setbkcolor(BACKGROUND_COLOR);cleardevice();FlushMouseMsgBuffer();Draw_ChessBoard();Show_Side_ChessColor(humanSide);Show_Side_ChessColor(humanSide);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再补充一下头文件</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Chess.h&quot;#include&lt;graphics.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-2-显示用户提示会话以及胜负结果"><a href="#3-2-显示用户提示会话以及胜负结果" class="headerlink" title="3.2　显示用户提示会话以及胜负结果"></a>3.2　显示用户提示会话以及胜负结果</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示双方各自执棋情况提示void Chess::Show_Side_ChessColor(Object humanSide) &#123;settextstyle(18, 0, _T(&quot;楷体&quot;));outtextxy(WIDTH - GRID_SIZE * 6, 6, _T(humanSide &#x3D;&#x3D; Black_Chess ? &quot;AI：白    人：黑&quot; : &quot;AI：黑    人：白&quot;));&#125;&#x2F;&#x2F;显示会话void Chess::Show_Dialog(char* dialog)&#123;settextstyle(20, 0, _T(&quot;Consolas&quot;));outtextxy(30, 5, _T(dialog));&#125;&#x2F;&#x2F;显示博弈结果void Chess::Show_Result(bool humanWin)&#123;settextstyle(30, 0, _T(&quot;楷体&quot;));if (humanWin) &#123;setcolor(RED);outtextxy(WIDTH &#x2F; 2 - GRID_SIZE * 2, 0, _T(&quot;你赢了！&quot;));&#125;else &#123;setcolor(GREEN);outtextxy(WIDTH &#x2F; 2 - GRID_SIZE * 2, 0, _T(&quot;你输了！&quot;));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-绘制棋子"><a href="#3-3-绘制棋子" class="headerlink" title="3.3　绘制棋子"></a>3.3　绘制棋子</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;指定位置画出一颗棋子void Chess::Show_A_Chess(int x, int y, int color)&#123;x -&#x3D; LEFT - 1, y -&#x3D; TOP - 1;x *&#x3D; GRID_SIZE, y *&#x3D; GRID_SIZE;setcolor(color);setfillcolor(color);setfillstyle(BS_SOLID);fillcircle(x, y, GRID_SIZE &#x2F; 2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、实现棋手走棋"><a href="#4、实现棋手走棋" class="headerlink" title="4、实现棋手走棋"></a>4、实现棋手走棋</h3><h4 id="4-1-棋手的初始化"><a href="#4-1-棋手的初始化" class="headerlink" title="4.1　棋手的初始化"></a>4.1　棋手的初始化</h4><p>为棋手类添加数据成员，表示棋盘</p><p>Man.h</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:Chess* ch;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实现棋手对象的初始化</p><p>Man.cpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;初始化void Man::Init(Chess* chess)&#123;this-&gt;ch &#x3D; chess;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在cpp文件中补充上头文件</p><p>Man.cpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Man.h&quot;#include&lt;graphics.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在ChessGame的构造函数中，实现棋手的初始化。</p><p>ChessGame.cpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;构造函数ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)&#123;this-&gt;man &#x3D; man;this-&gt;ai &#x3D; ai;this-&gt;ch &#x3D; chess;man-&gt;Init(chess);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-显示鼠标位置"><a href="#4-2-显示鼠标位置" class="headerlink" title="4.2　显示鼠标位置"></a>4.2　显示鼠标位置</h4><p>为了用户能知道此时光标的位置,我们可以用四条斜线对光标位置进行定位,使用户能清晰地看到此时鼠标的位置。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示鼠标位置void Man::Show_Mouse(int x, int y, int color)&#123;static const int p1[4][2] &#x3D; &#123; &#123; MOUSE_P1 ,MOUSE_P1 &#125;,&#123; MOUSE_P1,-MOUSE_P1 &#125;,&#123; -MOUSE_P1,MOUSE_P1 &#125;,&#123; -MOUSE_P1,-MOUSE_P1 &#125; &#125;;static const int p2[4][2] &#x3D; &#123; &#123; MOUSE_P2 ,MOUSE_P2 &#125;,&#123; MOUSE_P2,-MOUSE_P2 &#125;,&#123; -MOUSE_P2,MOUSE_P2 &#125;,&#123; -MOUSE_P2,-MOUSE_P2 &#125; &#125;;setlinecolor(color);x *&#x3D; GRID_SIZE, y *&#x3D; GRID_SIZE;for (int i &#x3D; 0; i &lt; 4; ++i)line(x + p1[i][0], y + p1[i][1], x + p2[i][0], y + p2[i][1]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道用户的鼠标应该要进行实时的更新,因此我们需要在添加一个函数在用户移动鼠标时更新界面。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;移动鼠标时更新界面void Man::Move_Mouse(int x, int y, int nx, int ny)&#123;Show_Mouse(x, y, BACKGROUND_COLOR);Show_Mouse(nx, ny, MOUSE_COLOR);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-棋手走棋"><a href="#4-3-棋手走棋" class="headerlink" title="4.3　棋手走棋"></a>4.3　棋手走棋</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;棋手下棋接口void Man::human_go(Chess_Position&amp; position, Object side)&#123;MOUSEMSG m;int nowx &#x3D; -1, nowy &#x3D; -1;while (1) &#123;m &#x3D; GetMouseMsg();int windowx &#x3D; (m.x + (GRID_SIZE &gt;&gt; 1)) &#x2F; GRID_SIZE;int windowy &#x3D; (m.y + (GRID_SIZE &gt;&gt; 1)) &#x2F; GRID_SIZE;int chessx &#x3D; windowx + LEFT - 1;int chessy &#x3D; windowy + TOP - 1;if (chessx &gt;&#x3D; LEFT &amp;&amp; chessx &lt;&#x3D; RIGHT &amp;&amp; chessy &gt;&#x3D; TOP &amp;&amp; chessy &lt;&#x3D; DOWN) &#123;switch (m.uMsg)&#123;case WM_MOUSEMOVE:     &#x2F;&#x2F;移动if (nowx !&#x3D; windowx || nowy !&#x3D; windowy)Move_Mouse(nowx, nowy, windowx, windowy);break;case WM_LBUTTONDOWN:  &#x2F;&#x2F;按下if (chess[chessy][chessx] !&#x3D; EMPTY)break;ch-&gt;Show_A_Chess(chessx, chessy, side &#x3D;&#x3D; Black_Chess ? BLACK_CHESS_COLOR : WHITE_CHESS_COLOR);position &#x3D; &#123; chessy ,chessx &#125;;return;&#125;nowx &#x3D; windowx, nowy &#x3D; windowy;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、添加数据成员"><a href="#5、添加数据成员" class="headerlink" title="5、添加数据成员"></a>5、添加数据成员</h3><p>为了便于调用各个类的功能，在ChessGame中，添加3个数据成员，并在构造函数中初始化这三个数据成员。</p><p>ChessGame.h</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once#include&quot;Man.h&quot;#include&quot;AI.h&quot;#include&quot;Chess.h&quot;&#x2F;&#x2F;可以调节#define compSide 0&#x2F;&#x2F;0：AI为黑1：AI为白class ChessGame&#123;public:&#x2F;&#x2F;构造函数ChessGame(Man*, AI*, Chess*);&#x2F;&#x2F;下棋接口void play();  private:Man* man;AI* ai;Chess* ch;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、细节修改"><a href="#6、细节修改" class="headerlink" title="6、细节修改"></a>6、细节修改</h3><p>修改项目的字符集为“多字节字符集”，因为我们要让编译器不增加宏定义——UNICODE。（是否增加了宏定义UNICODE，会影响了一些Windows API的使用。）<br><img src="/2022/09/08/wu-zi-qi-ai-yi/图3.png" alt></p><p>至此，我们第一部分整体框架的设计已经结束了，简单实现了界面，但还没实现AI下棋部分，AI部分的算法包含了Min-Max算法和αβ剪枝算法的实现。下一篇将优先实现AI算法中最重要的一环：评估函数的实现。</p><p>下一篇：<a href="http://ude123456.top/2022/09/13/wu-zi-qi-ai-er/">五子棋AI（二） </a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五子棋AI </tag>
            
            <tag> 博弈树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络</title>
      <link href="/2022/08/30/shen-jing-wang-luo/"/>
      <url>/2022/08/30/shen-jing-wang-luo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人工智能主要是机器学习，机器学习主要是深度学习，深度学习实际上算是机器学习的子领域，而要进行深度学习必然要接触人工神经网络。</p></blockquote><h2 id="1-什么是神经网络"><a href="#1-什么是神经网络" class="headerlink" title="1. 什么是神经网络"></a>1. 什么是神经网络</h2><p>　　神经网络是一种模拟人脑的神经网络以期能够实现类人工智能的<a href="https://so.csdn.net/so/search?q=机器学习&amp;spm=1001.2101.3001.7020">机器学习</a>技术。人脑中的神经网络是一个非常复杂的组织。成人的大脑中估计有1000亿个神经元之多。<br><img src="/2022/08/30/shen-jing-wang-luo/图1.jpg" alt><br>　　人工神经网络（artificial neural network，ANN），简称神经网络（neural network，NN)，是一种模仿生物神经网络的结构和功能的数学模型或计算模型。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统。现代神经网络是一种非线性统计性数据建模工具，常用来对输入和输出间复杂的关系进行建模，或用来探索数据的模式。</p><p>  神经网络主要由：<strong>输入层</strong>，<strong>隐藏层</strong>，<strong>输出层</strong>构成。当隐藏层只有一层时，该网络为<strong>两层神经网络</strong>，由于输入层未做任何变换，可以不看做单独的一层。实际中，网络输入层的每个神经元代表了一个特征，输出层个数代表了<strong>分类标签</strong>的个数（在做二分类时，如果采用sigmoid分类器，输出层的神经元个数为1个；如果采用softmax分类器，输出层神经元个数为2个)，而隐藏层层数以及隐藏层神经元是由人工设定。一个基本的三层神经网络可见下图：<br><img src="/2022/08/30/shen-jing-wang-luo/图2.jpg" alt></p><h3 id="1-1-从逻辑回归到神经元"><a href="#1-1-从逻辑回归到神经元" class="headerlink" title="1.1 从逻辑回归到神经元"></a>1.1 从逻辑回归到神经元</h3><p>  为了便于大家理解，我们先回顾一下<strong>逻辑回归</strong>。逻辑回归模型如下： <script type="math/tex">h_\theta(x) = \frac{1}{1+e{-\theta^T x}}</script><br>  其中 $z=\theta^Tx$=$\theta_0+\theta_1x_1+\theta_2x_2$ ， $h_\theta(x)=g(z)=\frac{1}{1+e^{−z}}$<br>  对此我们可以用以下结构进行理解：<br><img src="/2022/08/30/shen-jing-wang-luo/图3.jpg" alt><br>  根据上图，我们可以看出，逻辑回归可以分为<strong>线性变换</strong>部分与<strong>非线性变换</strong>部分。而<strong>只有输入层与输出层且输出层只有一个神经元</strong>的神经网络的结构便于逻辑回归一致。只不过在神经网络中，<strong>线性变换（求和）</strong>与<strong>非线性变换</strong>被集成在一个神经元（隐藏层或输出层)中。如下图所示：<br><img src="/2022/08/30/shen-jing-wang-luo/图4.jpg" alt><br>  于是，对于具有多层或多个输出神经元的神经网络就不难理解了。其<strong>每个</strong>隐藏层<strong>神经元</strong>/输出层<strong>神经元</strong>的值（<strong>激活值</strong>），都是由上一层神经元，经过<strong>加权求和</strong>与<strong>非线性变换</strong>而得到的。其中<strong>非线性变换函数（又被称为激活函数)</strong>可以是：$sigmoid、tanh、relu $等函数。</p><h3 id="1-2-神经网络"><a href="#1-2-神经网络" class="headerlink" title="1.2 神经网络"></a>1.2 神经网络</h3><p>  根据1.1中所讲述，我们可以得到以下这样一个基本的<strong>三层</strong>神经网络：<br><img src="/2022/08/30/shen-jing-wang-luo/图5.jpg" alt><br>  其中 $x_i(i=1,2,3)$ 为输入层的值，$a^{(k)}_i(k=1,2,3…,K；i=1,2,3…,N_k)$，表示第 $k$ 层中，第$i$个神经元的激活值，$N_k$ 表示第 $k$ 层的神经元个数。当$k=1$时即为输入层，即$a^{(1)}_i=x_i$，而$x_0=1$与$a^{(2)}_0=1$ 为偏置项。   为了求最后的<strong>输出值 $h_θ(x)=a^{(3)}_1$</strong>，我们需要计算隐藏层中每个神经元的激活值 $a^{(k)}_{ji}(k=2,3)$。而隐藏层/输出层的每一个神经元，都是由上一层神经元经过<strong>类似逻辑回归</strong>计算而来。我们可以使用下图进行理解：<br><img src="/2022/08/30/shen-jing-wang-luo/图6.jpg" alt><br>  我们使用 $a^{(k)}_{ji}$来表示第 $k$ 层的参数（边权)，其中下标 $j$ 表示第 $k+1$ 层的第 $j$ 个神经元，$i$ 表示第 $k$ 层的第 $i$ 个神经元。于是我们可以计算出<strong>隐藏层</strong>的三个<strong>激活值</strong>：　　　</p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}_{1}=g(\theta^{(1)}_{10}x_0+\theta^{(1)}_{11}x_1+\theta^{(1)}_{12}x_2+\theta^{(1)}_{13}x_3)</script></p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}_{2}=g(\theta^{(1)}_{20}x_0+\theta^{(1)}_{21}x_1+\theta^{(1)}_{22}x_2+\theta^{(1)}_{23}x_3)</script></p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}_{3}=g(\theta^{(1)}_{30}x_0+\theta^{(1)}_{31}x_1+\theta^{(1)}_{32}x_2+\theta^{(1)}_{33}x_3)</script></p><p>  再将隐藏层的三个激活值以及偏置项（ $a^{(2)}_{0}，a^{(2)}_{1}，a^{(2)}_{2}，a^{(2)}_{3}$ ）用来计算出输出层神经元的<strong>激活值</strong>即为该神经网络的输出：</p><p>　　　　　　　　　　<script type="math/tex">a^{(3)}_{1}=g(\theta^{(2)}_{10}a^{(2)}_0+\theta^{(2)}_{11}a^{(2)}_1+\theta^{(2)}_{12}a^{(2)}_2+\theta^{(2)}_{13}a^{(2)}_3)</script></p><p>  其中 $g(z)$ 为<strong>非线性变换函数（激活函数）</strong>。   </p><p>　　到此，我们就大致了解了什么是神经网络了。</p><h3 id="1-3-为什么要使用神经网络"><a href="#1-3-为什么要使用神经网络" class="headerlink" title="1.3 为什么要使用神经网络"></a>1.3 为什么要使用神经网络</h3><p>  首先，神经网络应用在分类问题中效果很好。 工业界中分类问题居多。LR或者linear SVM更适用<strong>线性分类</strong>。如果数据<strong>非线性可分</strong>（现实生活中多是非线性的），LR通常需要靠特征工程做特征映射，增加高斯项或者组合项；SVM需要选择核。 而增加高斯项、组合项会产生很多没有用的维度，增加计算量。GBDT可以使用弱的线性分类器组合成强分类器，但维度很高时效果可能并不好。而神经网络在三层及以上时，能够很好地进行<strong>非线性可分</strong>。现在我们使用下面的例子进行一下解释。<br>  有这样一组样本，如下图：<br><img src="/2022/08/30/shen-jing-wang-luo/图7.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图8.jpg" alt><br>  若我们需要对上图中的样本进行分类，直观来看，<strong>很难找到一条线性分类边界对其进行分类</strong>，而观察上表中的输入输出值，我们可以看出分类结果与输入值是<strong>异或</strong>关系。<strong>而逻辑回归可以通过改变参数，来实现“与”、“或”、“非”简单操作</strong>。   （1）我们先来观察一下<strong>逻辑回归</strong>实现<strong>逻辑“与”操作</strong>，假设模型函数如下：</p><p>　　　<script type="math/tex">h^{(1)}_{\theta}(x)=g(−30+20x_1+20x_2)=\frac{1}{1+e^{−(−30+20x_1+20x_2)}}</script></p><p>    对应结构与结果为：<br><img src="/2022/08/30/shen-jing-wang-luo/图9.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图10.jpg" alt><br>  （2）<strong>逻辑回归</strong>实现<strong>逻辑“或非”操作</strong>，假设模型函数如下：</p><p>　　　<script type="math/tex">h^{(1)}_{\theta}(x)=g(−10-20x_1-20x_2)=\frac{1}{1+e^{−(−10-20x_1-20x_2)}}</script></p><p>    对应结果为：<br><img src="/2022/08/30/shen-jing-wang-luo/图11.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图12.jpg" alt><br>  （3）<strong>逻辑回归</strong>实现<strong>逻辑“或”操作</strong>，假设模型函数如下：</p><p>　　　<script type="math/tex">h^{(1)}_{\theta}(x)=g(−10+20x_1+20x_2)=\frac{1}{1+e^{−(−10+20x_1+20x_2)}}</script></p><p>    对应结果为：<br><img src="/2022/08/30/shen-jing-wang-luo/图13.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图14.jpg" alt><br>  <strong>观察（1）（2）中的 $h^{(1)}_{\theta}(x)$ 与 $h^{(2)}_{\theta}(x)$ 的值，通过“或”操作，便能够得到“异或”操作的结果。</strong><br><img src="/2022/08/30/shen-jing-wang-luo/图15.jpg" alt><br>  也就是说，若将三个<strong>逻辑回归</strong>操作进行<strong>叠加</strong>，便能够对上述例子进行<strong>非线性分类</strong>。大致结构图可理解为下：<br><img src="/2022/08/30/shen-jing-wang-luo/图16.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图17.jpg" alt><br>  而对<strong>线性分类器</strong>的逻辑与和逻辑或的<strong>组合</strong>可以完美的对平面样本进行分类。<br><img src="/2022/08/30/shen-jing-wang-luo/图18.jpg" alt><br>  隐层决定了最终的分类效果 ：<br><img src="/2022/08/30/shen-jing-wang-luo/图19.jpg" alt><br>  由上图可以看出，随着隐层层数的增多，凸域将可以形成任意的形状，因此可以解决任何复杂的分类问题。实际上，Kolmogorov理论指出：双隐层感知器就足以解决任何复杂的分类问题。   <font size="4">于是我们可以得出这样的结论：<strong>神经网络</strong>通过将线性分类器进行组合叠加，能够较好地进行<strong>非线性分类</strong>。</font></p><hr><h2 id="2-神经网络目标函数"><a href="#2-神经网络目标函数" class="headerlink" title="2.神经网络目标函数"></a>2.神经网络目标函数</h2><p>  同样的，对于神经网络我们也需要知道其目标函数，才能够对目标函数进行优化从而学习到参数。<br>  假设神经网络的输出层只有一个神经元，该网络有 $K$ 层，则其目标函数为（若不止一个神经元，每个输出神经元的目标函数类似，仅仅是参数矩阵的不同）：</p><script type="math/tex; mode=display">J(θ)=−\frac{1}{m}[\sum\limits_{i=1}^my^{(i)}log(h_{\theta}(a^{(K−1)}))+(1−y^{(i)})log(1−h_{\theta}(a^{(K−1)}))]+\frac{\lambda}{2m}\sum\limits_{k=1}^{K-1}\sum\limits_{i=1}^{N_k}\sum\limits_{j=1}^{N_{k+1}}(\theta^{(k)}_{ji})^2</script><p>  其中 $a^{i}$ 倒数第2层的激活值，作为输出层的输入值。而其值为 $a^{(k)}=g(a^{(k−1)})$ ，$y^{(i)}$ 为实际分类结果 $0/1$，$m$ 为样本数，$N_k$ 为第 $k$ 层的神经元个数。</p><hr><h2 id="3-神经网络优化算法"><a href="#3-神经网络优化算法" class="headerlink" title="3.神经网络优化算法"></a>3.神经网络优化算法</h2><p>  神经网络与普通的分类器不同，其是一个巨大的网络，最后一层的输出与每一层的神经元都有关系。而神经网络的每一层，与下一层之间，都存在一个参数矩阵。我们需要通过优化算法求出每一层的参数矩阵，对于一个有 $K$ 层的神经网络，我们共需要求解出 $K−1$ 个参数矩阵。因此我们无法直接对目标函数进行梯度的计算来求解参数矩阵。<br>  对于神经网络的优化算法，主要需要两步：<strong>前向传播(Forward Propagation)</strong>与<strong>反向传播(Back Propagation)</strong></p><h3 id="3-1-前向传播"><a href="#3-1-前向传播" class="headerlink" title="3.1 前向传播"></a>3.1 前向传播</h3><p>  <strong>前向传播</strong>就是<strong>从输入层到输出层，计算每一层每一个神经元的激活值</strong>。也就是<strong>先随机初始化每一层的参数矩阵，然后从输入层开始，依次计算下一层每个神经元的激活值，一直到最后计算输出层神经元的激活值</strong>。<br>  以下面这个例子来看：<br><img src="/2022/08/30/shen-jing-wang-luo/图20.jpg" alt><br>    （1）随机初始化参数矩阵 <script type="math/tex">\Theta^{(1)}</script> 与 <script type="math/tex">\Theta^{(2)}</script>  ：</p><p>　　　　　　　　　<script type="math/tex">\Theta^{(1)}=\left[ \begin{matrix} \theta^{(1)}_{10} & \theta^{(1)}_{11} & \theta^{(1)}_{12} & \theta^{(1)}_{13}\\ \theta^{(1)}_{20} & \theta^{(1)}_{21} & \theta^{(1)}_{22} & \theta^{(1)}_{23} \end{matrix} \right] \Theta^{(1)}= \left[\begin{matrix}\theta^{(2)}_{10} & \theta^{(2)}_{11} & \theta^{(2)}_{12}\end{matrix}\right]</script><br>　　　　　　　　　<br>    （2）计算隐藏层的每个神经元激活值：</p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}_{1}=g(\theta^{(1)}_{10}x_0+\theta^{(1)}_{11}x_1+\theta^{(1)}_{12}x_2+\theta^{(1)}_{13}x_3)</script></p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}_{2}=g(\theta^{(1)}_{20}x_0+\theta^{(1)}_{21}x_1+\theta^{(1)}_{22}x_2+\theta^{(1)}_{23}x_3)</script></p><p>      即：</p><p>　　　　　　　　　　<script type="math/tex">a^{(2)}=g(\Theta^{(1)}x)</script>，其中$a^{(2)}=$$\left[\begin{matrix} a_1^{(2)} \\ a_2^{(2)} \end{matrix}\right],x=\left[\begin{matrix} x_0 \\ x_1\\x_2\\x_3 \end{matrix}\right]$，</p><p>    （3）计算隐藏层的每个神经元激活值：</p><p>　　　　　　　　　　<script type="math/tex">a^{(3)}_{1}=g(\theta^{(2)}_{10}a_0^{(2)}+\theta^{(2)}_{11}a_1^{(2)}+\theta^{(2)}_{12}a_2^{(2)})</script></p><p>      即：</p><p>　　　　　　　　　　<script type="math/tex">a^{(3)}=g(\Theta^{(2)}a^{(2)})</script>，其中$a^{(2)}=$$\left[\begin{matrix} a_0^{(2)} \\ a_1^{(2)} \\a_2^{(2)} \end{matrix}\right]$</p><p>  以上便是<strong>前向传播</strong>计算<strong>激活值</strong>的过程。</p><h3 id="3-2-反向传播"><a href="#3-2-反向传播" class="headerlink" title="3.2 反向传播"></a>3.2 反向传播</h3><p>  <strong>反向传播</strong>总的来说就是<strong>根据前向传播计算出来的激活值，来计算每一层参数的梯度，并从后往前进行参数的更新</strong>。<br>  在介绍反向传播的计算步骤之前，我们先引入一个概念—-除输入层外每个神经元节点的<strong>“损失”</strong> ，${\delta}_j^k$ 表示第 $k$ 层第 $j$ 个神经元的损失。<br>  于是我们可以计算求得（除输入层）每一层神经元的损失（以上一个例子来解释）：</p><p>　　　　　　　　　　<script type="math/tex">{\delta}_1^{(3)}=a_1^{(3)}-y_1</script></p><p>  其中 $y_1$ 为实际值。向量化表示如下：</p><p>　　　　　　　　　　<script type="math/tex">{\delta}^{(3)}=a^{(3)}-y</script></p><p>　　　　　　　　　　<script type="math/tex">{\delta}^{(2)}=((\Theta^{(2)})^T){\delta}^{(3)}{\times}g'(z^{(2)})</script></p><p>  其中”$\times$”表示两个矩阵对应位置上元素相乘，$g’(z^{(2)})$ 是对函数求导。而</p><p>　　　　<script type="math/tex">z^{(2)}=\left[\begin{matrix}\theta^{(1)}_{10}x_0+\theta^{(1)}_{11}x_1+\theta^{(1)}_{12}x_2 +\theta^{(1)}_{13}x_3 &\theta^{(1)}_{20}x_0+\theta^{(1)}_{21}x_1+\theta^{(1)}_{22}x_2+\theta^{(1)}_{23}x_3\end{matrix}\right]</script></p><p>  由上可看出，第二层的损失 ${\delta}^{(2)}$ 是<strong>基于第三层的损失</strong> ${\delta}^{(3)}$ 计算而来。也就是说，我们可以先计算第三层的损失并对第二层的参数矩阵进行更新，再利用第三层的损失计算第二层的损失以及更新第一层的参数矩阵（<strong>至于为何可以这样进行，将在后面进行证明</strong>）。<br>  于是，基于反向传播算法的梯度更新步骤如下：<br>    （1）计算每一层的损失：${\delta}^{(k)}$（见上面所示）。<br>    （2）计算每一层的 $\Delta$ (初始化为0)：$ \Delta^{(k)} = \Delta^{(k)} + \delta^{(k+1)} (a{(k)})T $<br>    （3）计算每一个参数的<strong>梯度</strong>：</p><p>　　　　　　　　　　<script type="math/tex">D^{(k)}_{ji}=\frac{1}{m}\Delta^{(k)}_{ji}+\lambda\Theta^{(k)}_{(ji)},如果i\neq0</script></p><p>　　　　　　　　　　　　<script type="math/tex">D^{(k)}_{ji}=\frac{1}{m}\Delta^{(k)}_{ji},如果i=0</script></p><p>  也就是说$\frac{\delta J(\Theta)}{\delta\Theta^{k}_{ji}}=D^{(k)}_{ji}$。于是就可以使用梯度下降来进行参数的求解了。</p><h3 id="3-3-反向传播的推导"><a href="#3-3-反向传播的推导" class="headerlink" title="3.3 反向传播的推导"></a>3.3 反向传播的推导</h3><p>  大家可能都会有疑问，为什么求梯度时，要先对后一层进行计算，并利用其结果来求前一层的梯度？我们将针对如下例子进行推导证明：<br><img src="/2022/08/30/shen-jing-wang-luo/图20.jpg" alt><br>  第一层的参数为：</p><p>　　　　　　　　　　<script type="math/tex">\Theta^{(1)}=\left[ \begin{matrix} \theta^{(1)}_{10} & \theta^{(1)}_{11} & \theta^{(1)}_{12} & \theta^{(1)}_{13}\\ \theta^{(1)}_{20} & \theta^{(1)}_{21} & \theta^{(1)}_{22} & \theta^{(1)}_{23} \end{matrix} \right] \tag{3}</script></p><p>  第二层的参数为：</p><p>　　　　　　　　　　<script type="math/tex">\Theta^{(2)}=\left[\begin{matrix}\theta^{(2)}_{10} & \theta^{(2)}_{11} & \theta^{(2)}_{12}\end{matrix}\right]</script></p><p>  我们先来对第二层的参数求梯度 $\frac{\delta J(\Theta)}{\delta\theta^{(2)}}$：<br><img src="/2022/08/30/shen-jing-wang-luo/图21.jpg" alt><br>  其中 $y^i$ 为实际值， $g(θ^{(2)}a^{(2)})=a^{(3)}$。<br><img src="/2022/08/30/shen-jing-wang-luo/图22.jpg" alt><br>  这一步的推导过程与逻辑回归一样，详细可参考<a href="https://blog.csdn.net/t46414704152abc/article/details/79574003">逻辑回归的理解</a>。   </p><p>　　现在我们来对第一层的参数求梯度$\frac{\delta J(\Theta)}{\delta\theta^{(1)}}$ ：<br><img src="/2022/08/30/shen-jing-wang-luo/图23.jpg" alt><br>  先对中括号内的求导：<br><img src="/2022/08/30/shen-jing-wang-luo/图24.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图25.jpg" alt><br>  故：<br><img src="/2022/08/30/shen-jing-wang-luo/图24.jpg" alt><img src="/2022/08/30/shen-jing-wang-luo/图26.jpg" alt><br>  对比着3.2中的公式，我们可以看出，第 $k$ 层的梯度可以根据第 $k+1$ 层的<strong>损失</strong>来计算（上式是用第 22 的损失来推导第 11 层的梯度)。   到此，反向传播的推导过程就完成了。如果对式子还有不理解的，可以自己动手多试试。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人生海海》读后感</title>
      <link href="/2022/05/01/ren-sheng-hai-hai-du-hou-gan/"/>
      <url>/2022/05/01/ren-sheng-hai-hai-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<font size="6">　　　　“回首向来萧瑟处，也无风雨也无晴”</font><font size="5">　　　　　　　　　　　　　　　　　　　　　——《人生海海》读后感</font><p>　　看完《人生海海》，不知道为什么有一种强烈的欲望想要写一篇读后感。人生海海来自于闽南方言，也许是看到人生海海这个书名而对写读后感有一丝冲动。本来我一直以为这本书是作者麦家的自传，直到查了度娘我才死心。想来也是，什么人才能拥有上校一样的人生呢？经历战乱而独善其身，横跨时代而名声依旧，偏居一隅却众望所归。<br>　　生活，不是我们该活过的样子，而是我们该记住的样子。人生百态，世态万千，我觉得人不必活到多么令人高不可攀的境界，也不需要奢求自己活到多么仰望不及的高度，但至少能尽量做到一个有本事有担当且睿智的人。不管天大的事都要觉得不足为惧，凡事看得淡，却又不随波逐流，有自己的一些想法，有自己做事的方式，不浮夸，不张扬，不急不躁。心有雷霆面若静湖，这是生命的厚度，是沧桑堆积起来的。 “人生海海，潮落之后是潮起，你说那是消磨，笑柄，罪过，可那就是我的英雄主义。”<br>　　麦家在书中写道：“人要学会放下，放下是一种饶人的善良，也是饶过自己的智慧。”世界很宽阔，可是人心却很狭窄，能装下的东西太少了，一不小心就满了，所以需要常常清理一下。被执念困扰，因为愧疚自杀的“爷爷”，因爱生恨的林护士，执着到成疯子的上校哪一个不是痛苦不已。所谓放下，也是跟自己和解，原谅自己的一个过程。看看回到孩童智商的上校和为爱守护上校的林护士，又何尝不是一种放下呢？“人生海海，我们像海滩上的两粒沙一样相遇。”<br>　　“人生海海，敢死不叫勇气，活着才需要勇气。有人说人出生是不平等的，而在这世界上唯一平等的只有死亡，我认为这个见解十分中肯。但死去不是人生目标，而只是人生中的一部分。活着才更需要勇气，为了活着，也许我们慢慢学会伪装，变得八面玲珑；也或许我们会活得自我。<br>　　在我看来，人的一生总是按照既定轨迹发展。我记得曾经看视频时，复旦大学的王德峰教授说过的一句话我至今仍然记得，“人到四十岁，还是信力不信命，那只能说明此人悟性太差。”<br>　　而我理解的命运既无关乎鬼神，也无关宗教，我认为它是一种微妙的平衡：财富平衡，健康平衡，幸福感平衡，得失平衡。用科学来解释就是能量守恒，有得必有失，这是我这几年明白的一个道理。当你得到一些东西的时候，不要得意忘形，因为也许你会为之失去很多。生活阴差阳错，我被生活推着向前，身不由己，却甘之如饴。我知道天地为炉，世间万物，芸芸众生，都在煎熬之中。我知道，人世间有很多苦难，没有公平可言，让人摸不着头脑。<br>　　可是既然生活选择了我们，我们也选择了生活，就要放平心态，好好生活。命运没有给我们安排一夜暴富得“幸运”，也不会给我们安排跨越不过得“霉运”。顺境时，不卑不亢，且待风落；逆境时，不卑不亢，且待风起。“命里有时终须有，命里无时莫强求”。<br>　　世上只有一种英雄主义，就是看清了生活的本质后，依然热爱生活。<br>　　生活从来不完美，不完美才是生活。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径(Dijkstra算法)</title>
      <link href="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/"/>
      <url>/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>Dijkstra算法刚接触时确实有点难以理解，尤其是代码的实现，但其背后的逻辑实际上是用贪心算法来支撑的。但是在算法学习中Dijkstra算法又是最基本的一种算法，对于求解单源最短路径有着极大的作用。在这里我简单讲一下自己的理解，我的代码参考了《图解数据结构》，该代码适合稠密图，使用的是邻接矩阵来存储的图。 </p><hr><h2 id="1、Dijkstra算法主要步骤"><a href="#1、Dijkstra算法主要步骤" class="headerlink" title="1、Dijkstra算法主要步骤"></a>1、Dijkstra算法主要步骤</h2></blockquote><p><img src="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/Dijkstra算法步骤.png" alt></p><p>对于贪心算法，简单描述一下：<br>贪心算法正如其名字一样，贪心算法只注重眼前利益，就像贪心的小人一样，因此得名贪心算法，该算法即从一个初始解，一步步选取当前最优解，最终得出近似的最优解（注意：不一定是该问题的最优解，而是近似于最优解）。<br>实现该算法的基本过程如下。<br>（1）从问题的某一初始解出发。<br>（2）while能向给定总目标前进一步。<br>（3）求出可行解的一个解元素。<br>（4）由所有解元素组合成问题的一个可行解。<br>（想更深入了解请参考链接<a href="https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187）">https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187）</a></p><hr><h2 id="2、Dijkstra算法小结"><a href="#2、Dijkstra算法小结" class="headerlink" title="2、Dijkstra算法小结"></a>2、Dijkstra算法小结</h2><p> 1、Dijkstra算法一般是用来解决单源最短路径问题（指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。）<br> 2、其时间复杂度仅为O(n^2^)，并且非常高效，甚至可以优化成O(log2n)。<br> 3、Dijkstra算法中权值只能为正数，若权值为负数则不能使用该算法。（权值即图各个边所赋予的值）  </p><hr><h2 id="3、算法实现"><a href="#3、算法实现" class="headerlink" title="3、算法实现"></a>3、算法实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; #define SIZE 7#define NUMBER 6#define INFINITE 123456  &#x2F;&#x2F;宏定义无穷大 &#x2F;&#x2F;首先定义图的数组int Graph_Matrix[SIZE][SIZE];int Distance[SIZE];  &#x2F;&#x2F;路径长度 &#x2F;&#x2F;建立有向图void Create_Graph(int *Path_Cost)&#123;    int i,j;    for(i&#x3D;0;i&lt;SIZE;i++)    &#123;        for(j&#x3D;0;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;若是在对角线上，设置元素值为0            if(i&#x3D;&#x3D;j)            &#123;                Graph_Matrix[i][j]&#x3D;0;            &#125;            &#x2F;&#x2F;其他位置元素的值为无穷大            else            &#123;                Graph_Matrix[i][j]&#x3D;INFINITE;            &#125;        &#125;    &#125;     int End_Point,Start_Point;  &#x2F;&#x2F;图的边起始位置和终止位置     &#x2F;&#x2F;存入图的各个数据：边，权重    i&#x3D;0;    while(i&lt;SIZE)    &#123;        Start_Point&#x3D;Path_Cost[i*3];  &#x2F;&#x2F;在邻接矩阵中的行        End_Point&#x3D;Path_Cost[i*3+1];  &#x2F;&#x2F;在邻接矩阵中的列        &#x2F;&#x2F;图各边权值转化为邻接矩阵中所在的位置        Graph_Matrix[Start_Point][End_Point]&#x3D;Path_Cost[i*3+2];        i++;    &#125;&#125; &#x2F;&#x2F;打印邻接矩阵void Print_Matrix()&#123;    int i&#x3D;0,j&#x3D;0;    for(i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;vex&quot; &lt;&lt; i ;        for(j&#x3D;1;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;为了美观和可读性，将值为无穷大的元素打印为x            if(Graph_Matrix[i][j]&#x3D;&#x3D;INFINITE)            &#123;                cout &lt;&lt; setw(5) &lt;&lt; &quot;x&quot;;            &#125;            else            &#123;                cout &lt;&lt; setw(5) &lt;&lt; Graph_Matrix[i][j];            &#125;        &#125;        cout &lt;&lt; endl;    &#125;&#125; &#x2F;&#x2F;开始求解单源最短路径void Shortest_Path(int vertex1,int vertex_total)&#123;    int Shortest_vertex&#x3D;1;  &#x2F;&#x2F;初始化    int Shortest_distance;  &#x2F;&#x2F;最短距离    int flag[SIZE];  &#x2F;&#x2F;标志数组，标志顶点是否已经遍历过    int i,j;     for(i&#x3D;1;i&lt;&#x3D;vertex_total;i++)    &#123;        flag[i]&#x3D;0;  &#x2F;&#x2F;初始化标志数组        Distance[i]&#x3D;Graph_Matrix[vertex1][i];  &#x2F;&#x2F;将图的权值存入Distance[]数组中    &#125;     flag[vertex1]&#x3D;1;  &#x2F;&#x2F;标志该顶点已经找过    Distance[vertex1]&#x3D;0;  &#x2F;&#x2F;顶点到该顶点自身的距离为0     for(i&#x3D;0;i&lt;&#x3D;vertex_total-1;i++)    &#123;        Shortest_distance&#x3D;INFINITE;        for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;找到最小权边的顶点            if(flag[j]&#x3D;&#x3D;0 &amp;&amp; Distance[j]&lt;&#x3D;Shortest_distance)            &#123;                Shortest_distance&#x3D;Distance[j];                Shortest_vertex&#x3D;j;            &#125;        &#125;         flag[Shortest_vertex]&#x3D;1;  &#x2F;&#x2F;找到下一个顶点后标记为已经经过         for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;以上一个顶点为父节点，若前一个顶点和下一个权边的和最小，则更新最短路径            if(flag[j]&#x3D;&#x3D;0 &amp;&amp;               Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j]               &lt;Distance[j])            &#123;                &#x2F;&#x2F;更新最短路径                Distance[j]&#x3D;Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j];            &#125;        &#125;    &#125;&#125; int main()&#123;    int Path_Cost[9][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;1,3,5&#125;,&#123;1,4,1&#125;,&#123;1,5,3&#125;,&#123;1,6,4&#125;,                         &#123;2,5,3&#125;,&#123;4,5,7&#125;,&#123;4,6,6&#125;,&#123;4,3,2&#125;&#125;;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;此范例图的邻接矩阵如下：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;顶点   vex1 vex2 vex3 vex4 vex5 vex6&quot; &lt;&lt; endl;    Create_Graph(&amp;Path_Cost[0][0]);    Print_Matrix();    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;顶点1到各顶点最短距离的最终结果&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    &#x2F;&#x2F;查找最短路径    Shortest_Path(1,NUMBER);    for(int i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;顶点1&quot; &lt;&lt; &quot;到顶点&quot; &lt;&lt; i &lt;&lt; &quot;的最短距离&#x3D;&quot; &lt;&lt; Distance[i] &lt;&lt; endl;    &#125;     system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树(Kruskal算法)</title>
      <link href="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/"/>
      <url>/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>一下子就接触算法原理和一堆七七八八的术语概念，无疑是让人头疼的，因为无端出现这么多的信息，都不知道它的来历，又不知道这些信息到底有什么用，所以我们就从最简单的内容开始，将这个算法完整地梳理一下吧。</p><hr><h2 id="1、知识脉络梳理"><a href="#1、知识脉络梳理" class="headerlink" title="1、知识脉络梳理"></a>1、知识脉络梳理</h2><h3 id="1、树形结构"><a href="#1、树形结构" class="headerlink" title="1、树形结构"></a>1、树形结构</h3><p>首先，先来看看一个简单的数据结构——树。<br>树形结构，从字面上来理解，就是像我们生活中常见的树长的很类似。在数据结构中我们无非就是将生活中的树倒过来看而已，也就是树根在上，树叶在下。这么设计其实也没什么特别的道理，只是在遍历树的时候，我们从树根开始，从树根往叶子节点出发。但是除了倒着放，其实我们也可以将他伸展开来放，例如下面的这棵树，其实也是一棵树</p></blockquote><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图1.png" alt></p><p>我们大致的想象一下，就像直接抓着树根将它拎起来，那么就自然变成了上图的样子了。</p><p>于是我们就发现，不管拎起是哪个节点，都会得到一棵树。也就是说，如果树根的位置对我们不再重要的话，树其实就等价于上面这样的图。</p><p>那么这样的图究竟是什么图呢？它有什么性质呢？所有的图都能看成是树吗？下面我们来看一下三种情况：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图2.png" alt></p><p>显然这三种情况<strong>都不是树</strong>。第一种是因为图中的边有方向了，一旦有了方向，图中连通的情况就被破坏了。我们都知道，树应该是全部连通的，也就是说你从任意一个节点开始，都可以走到树上任何位置。那么根据定义，<strong>不能全连通，肯定就不是树</strong>。情况2也不对，因为<strong>有了环</strong>，树是不应该有环的，大家应该没见过那种从树根还能再到树根的树吧，那不是成了老树精了？在我们定义中的树也是<strong>不能有环</strong>的，不然我们遍历的时候不是永远也找不到终点了吗？第三种情况则是因为有个别的点孤立在外，因此<strong>不能连通</strong>，所以也不是树。</p><p>所以总结一下，树就是可以全连通的（无向图），并且没有环的图。</p><h3 id="2、从图到树"><a href="#2、从图到树" class="headerlink" title="2、从图到树"></a>2、从图到树</h3><p>从上面的部分，其实我们可以发现，<strong>树的本质就是图</strong>，无非就是一些具有特殊性质的图。因此我们也经常能看到许多有关于树的算法会被纳入图论当中。</p><p>通过对树的观察，其实我们可以发现一条重要性质，对于一棵拥有n个节点的树而言，它会有n-1条边。因此如果超过n-1条边，证明当中一定存在环路，如果不理解的话，你可以简单画个图尝试一下。反之，如果小于n-1条边，那么一定存在不连通的部分。但我们需要注意，这个性质正向可以成立，反过来就不成立了，用数学中的概念来说就是，它是一个必要条件，但不是一个充分条件。也就是说并不是n个点和n-1条边就一定是树，这个画个图就很容易得出反例。</p><p>接下来我们就用这个性质来尝试解决一下由图转化成树的问题。</p><p>现在有一个稍微复杂的图，如下图：<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图3.png" alt><br>那么我们现在就根据这一个图生成一棵能够连通所有节点的树。根据上述的性质，我们的方法很明确，无非就是两种办法：</p><p>第一种办法是删边，既然是一个复杂图，说明边的数量肯定要超过n-1的，所以我们可以尝试去删减掉一些边，最后留下一棵树就可以了。</p><p>第二种做法则是增边，也就是说我们从零开始，一开始先把所有的边全部撤掉，然后一条一条地往一个集合当中添加n-1条边，让它变成一棵树。</p><p>那这两种方法哪种更好呢？我们可以想一下，我们每一次在删除边的时候是不是都需要考虑到<strong>是否会破坏树的连通关系</strong>，因此添加边的做法明显优于删减边的做法。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图4.png" alt></p><p>可以看看上图，如果我们删除AB这条边，就会发现这个已经不是连通图了，那必然也不可能成为一棵树。要判断连通关系，最好的方法就是先删除这条边，然后试着从A点出发，看看能否到达B点，如果能到达，则认为这条边是可以删除的，但是如果这么做的话，一旦图很大时，<strong>每一次删除需要遍历整张图</strong>，那么效率就会很低。并且每一次删除后，由于图的结构会发生 变化，我们还需要对这些变化进行存储，但由于他是一直动态变化，存储这些结果十分困难。</p><p>因此，删除边的方式可行，但是十分麻烦。</p><p>至此，我们知道了其实所谓的最小生成树就是从一个图当中选取n-1条边将他变换为一棵树的算法</p><h3 id="3、生成树"><a href="#3、生成树" class="headerlink" title="3、生成树"></a>3、生成树</h3><p>我们暂且不考虑带权问题，就先假设所有的边都是等权重的。</p><p>那么现在我们知道要采用添加边的方式，那我们选择一条边时，应该怎么判断这条有没有必要添加到集合中去呢？</p><p>树有一条性质是，树上任意的两个点，它们之间的路径有且只有一条，如果存在两点之间的路径有两条，那么必然可以形成一个环。那么我们就可以知道如果当前两个点之间已经存在通路的时候，就证明那么当前这两个点连成的边就不能再添加了，否则一定会出现环。因此我们需要设计的算法要<strong>维护树上点的连通性</strong>。</p><p>但是这又会有一个新问题，我们知道，在树结构当中，<strong>连通性是可以传递的</strong>。如果两个点之间连了一条边，并不仅仅只是这两个点连通，还包括了所有与这两个点之间连通的点都连通了。下面来看一个例子：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图5.png" alt></p><p>这张图当中A和B连了一条边，这不仅仅是A和B连通，而是<strong>左半边的集合和右半边集合的连通</strong>。所以，虽然A只是和B连通了，但是和C也连通了。AC这条边也一样不能被加入了。也就是说A和B连通，其实是<strong>A所在的集合和B所在的集合合并</strong>的过程。看到集合的合并我们就可以想到并查集，并查集算法就是用来解决集合合并和查询问题的。那么，显然可以用并查集来维护图中这些点集的连通性。关于并查集，如果不知道的朋友可以点击一下<a href="https://blog.csdn.net/bjweimengshu/article/details/108332389">传送门</a>进行了解。</p><p>所以，我们现在就得到了生成树。</p><h3 id="4、从生成树到最小生成树"><a href="#4、从生成树到最小生成树" class="headerlink" title="4、从生成树到最小生成树"></a>4、从生成树到最小生成树</h3><p>现在我们就可以为图中的每条边都加上权重，我们的目标很明确，就是要使得最后生成的树的所有权重之和最小。</p><p>比如，看下面这张图，我们现在想要使生成的树上所有边的权重和最小。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图6.jpg" alt></p><p>根据贪心算法，我们<strong>显然希望用尽量短的边来连通树</strong>。所以Kruskal算法的原理非常简单，就是对这些边的权值进行排序，依次从短到长遍历这些边，然后通过并查集来查询正在遍历的这条边是否能够被添加，直到所有边都遍历结束。</p><h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><h3 id="1、完美图解"><a href="#1、完美图解" class="headerlink" title="1、完美图解"></a>1、完美图解</h3><p>下面图解出自陈小玉老师所主编的书《趣学算法》中，朋友们可以借助理解算法。<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图7.jpg" alt><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图8.jpg" alt><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/图9.jpg" alt></p><h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100;int nodeset[N];int n, m;struct Edge&#123;int u;int v;int w;&#125;e[N * N];bool comp(Edge x, Edge y)&#123;return x.w &lt; y.w;&#125;void Init(int n)&#123;for (int i&#x3D;1; i &lt; n; i++)nodeset[i]&#x3D;i;&#125;int Merge(int a, int b)&#123;int p &#x3D; nodeset[a];int q &#x3D; nodeset[b];if (p &#x3D;&#x3D; q)&#123;return 0;&#125;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;检查所有结点，把集合号是q的改为p&#123;if (nodeset[i] &#x3D;&#x3D; q)nodeset[i] &#x3D; p;&#x2F;&#x2F;a的集合号赋值给b集合号&#125;return 1;&#125;int Kruskal(int n)&#123;int ans &#x3D; 0;for (int i &#x3D; 0; i &lt; m; i++)&#123;if (Merge(e[i].u, e[i].v))&#123;ans +&#x3D; e[i].w;n--;if (n &#x3D;&#x3D; 1)&#123;return ans;&#125;&#125;&#125;return 0;&#125;int main()&#123;cout &lt;&lt; &quot;输入结点数n和边数m:&quot;&lt;&lt;endl;cin &gt;&gt; n &gt;&gt; m;Init(n);cout &lt;&lt; &quot;输入结点数u,v和边值w:&quot;&lt;&lt;endl;for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;sort(e, e + m, comp);int ans &#x3D; Kruskal(n);cout &lt;&lt; &quot;最小的花费是：&quot; &lt;&lt;ans &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 树形结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
