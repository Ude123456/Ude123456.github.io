<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>散列表</title>
      <link href="/2022/11/14/san-lie-biao/"/>
      <url>/2022/11/14/san-lie-biao/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>顺序存储的结构类型有顺序表、栈、队列等，但他们都需要一个一个地按顺序对元素进行访问，如果要访问的总量很大时候，并且当我们要访问的这一元素位于末尾时，则查找效率就会很低。<br>散列表是一种<strong>空间换时间</strong>的存储结构，就是牺牲了存储空间来换取了查找数据的效率，但是如果需要的存储空间太大时，也会让我们感到头疼，所以我们往往需要在空间和时间两者当中进行权衡。</p></blockquote><hr><h2 id="1、什么是散列表"><a href="#1、什么是散列表" class="headerlink" title="1、什么是散列表"></a>1、什么是散列表</h2><p>如果在图书馆里要找一本书，那我们应该不会从第 1 本书一直找下去，因为这样实在是太慢了。回想一下我们到图书馆找书是怎么找的呢？首先是不是应该先找到你要找的这本书属于什么类别，例如科幻类、古典文学、武侠类等等，然后再在这一个类别当中进行查找。</p><p>还有我们平常学英语应该也要查字典，那么要查找一个单词的时候，我们肯定不会从头翻到尾，而是首先通过这个单词的首字母，找到对应的那一页；再找第 2 个字母、第 3 个字母……这样可以快速跳到那个单词所在的页。</p><p>其实这些就是运用了散列表的思想：在记录的存储地址和它的关键码之间建立一个确定的对应关系。这样，不需要经过比较，一次读取就能够得到所查元素。</p><p>散列表（Hash table，也叫哈希表），是<strong>根据键（Key）而直接访问在内存储存位置</strong>的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。<strong>这个映射函数称做散列函数，存放记录的数组称做散列表，由散列函数所得的存储地址称做散列地址</strong>。<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE1.png"><br>从上图中，我们也可以看出散列表不仅仅只是一种查找技术，同时也是一种存储技术。另外，从散列表的定义，我们也可以发现，散列方法是不适用于范围查找的，换言之，在散列表中，我们不可能找到最大或最小关键码的记录，也不可能找到在某一范围内的记录。</p><p>那么散列表的关键值都要不同，这时我们会发现出现一个严重的问题，如果对于两个不同的数据 ，我们计算到了同样的键值，那么就会出现冲突，此时该如何处理呢？</p><p>所以构造一个好的散列表，最重要的是做好以下两个步骤：</p><ol><li>设计一个”好”的散列函数来计算Key值。(好的哈希函数应尽可能避免冲突的出现，而且计算时应尽可能简洁快速)</li><li>出现了冲突时又该如何调整插入元素。</li></ol><hr><h2 id="2、散列函数设计方法"><a href="#2、散列函数设计方法" class="headerlink" title="2、散列函数设计方法"></a>2、散列函数设计方法</h2><h3 id="1、直接寻址法"><a href="#1、直接寻址法" class="headerlink" title="1、直接寻址法"></a>1、直接寻址法</h3><p>散列函数是关键码的线性函数，即：<br>     $$H(key)&#x3D;a\times key + b$$    式中，a 和 b 是常数</p><p>例如：关键码集合为{10,20,30,40,60,80,90}，选取一个散列函数为：$H(key)&#x3D;\frac{1}{10}key$ ,则散列表为：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE2.png"><br>适用情况：事先知道关键码，关键码集合<strong>不是很大并且连续性较好</strong>。</p><h3 id="2、除留余数法"><a href="#2、除留余数法" class="headerlink" title="2、除留余数法"></a>2、除留余数法</h3><p>假设散列表长度为 n，取一个不大于 n 但近似接近或等于 m 的质数 p，利用除留余数法的散列函数把关键字转换成散列地址。</p><p>散列函数为：<br>     $$H(key)&#x3D;key\quad mod\quad p$$    </p><p>例如，数据元素集合为a&#x3D;{78,7,99,13,25,53,59,30}，哈希表长度n取11时，并不会产生哈希冲突；当n取9时，就会产生哈希冲突。p的选取并不是固定的，需要自己进行判断，以此来选择最合适的p值。</p><p>通常情况下，哈希表的长度n习惯选取<strong>质数</strong>。<strong>对p的选择也十分重要，一般取素数或m</strong>，这样可以有效减少哈希冲突的发生。</p><p>在来看一个例子：现在有一组关键码，我们取p&#x3D;21，则会得到以下信息：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE3.png"><br>适用情况：除留余数法是一种最简单、也是最常见的构造散列函数的方法，并且<strong>不需要事先知道关键码的分布</strong>。</p><h3 id="3、数字分析法"><a href="#3、数字分析法" class="headerlink" title="3、数字分析法"></a>3、数字分析法</h3><p>如果关键字是位数较多的数字（比如手机号和学号），且这些数字部分存在相同规律，则可以采用抽取剩余不同规律部分作为散列地址。</p><p>如下图所示，有80个记录，每一行为一个记录中的键，假设表长为100，则可取两位十进制数组成哈希地址。<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE4.png"><br>通过对上图进行观察可以得出，第1,2列对应的数字都是相同的，而第3列和第8列存在着大量重复的数字（分别是3和2,7），因此不能选择它们成为哈希地址。而中间4位可以看作是随机的，所以可以从中任选两位作为哈希地址。</p><p>再来看一个更直白的应用，现在有一组学生的学号为：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE5.png"><br>这组学号的前7位取值相对比较集中，剩下的后两位取值较均匀，可以直接使用学号的最后两位作为哈希地址，所以这十个关键字的哈希地址分别为：<br>10、21、71、85、13、37、22、33、3、14。</p><p>适用情况：能预先估计出关键码的每一位上各种数字出现的频度，不同的关键码集合需要重新分析。</p><h3 id="4、平方取中法"><a href="#4、平方取中法" class="headerlink" title="4、平方取中法"></a>4、平方取中法</h3><p>对关键码平方后，按散列表大小，取中间若干位作为散列地址（<strong>平方</strong>后<strong>截取</strong>）。</p><p>它弥补了数字分析法的一些缺陷，因为我们有时并不能知道键的全部情况，取其中几位也不一定合适，而一个数平方后的中间几个数和原数的每一位都相关，由此我们就能得到随机性更强的哈希地址取的位数由表长决定。<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE6.png"><br>适用情况：事先不知道关键码的分布并且<strong>关键码的位数不是很大</strong>。</p><h3 id="5、折叠法"><a href="#5、折叠法" class="headerlink" title="5、折叠法"></a>5、折叠法</h3><p>将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>例如：设关键码为<u>2 5 3</u> <u>4 6 3</u> <u>5 8 7</u> <u>0 5</u>，散列地址为三位。<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE7.png"><br>适用情况：<strong>关键码很多</strong>，事先不知道关键码的分布。</p><hr><h2 id="3、解决冲突的方法"><a href="#3、解决冲突的方法" class="headerlink" title="3、解决冲突的方法"></a>3、解决冲突的方法</h2><p>我们在前面已经说过了，我们在构建散列表时，一个经常会碰到的问题是：不同的关键值经过散列函数的映射后，得到了一个同样的散列地址，这种现象就叫做冲突。那我们该如何解决冲突呢，方法总共有两类：开放定址法和拉链法。</p><p>用开放定址法处理冲突得到的散列表叫<strong>闭散列表</strong>；用拉链法处理冲突构造出的散列表叫<strong>开散列表</strong>。</p><h3 id="1、开放定址法"><a href="#1、开放定址法" class="headerlink" title="1、开放定址法"></a>1、开放定址法</h3><p>当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。<br>基本公式为：**$H(key) &#x3D; (key+di)\quad mod\quad TableSize$<strong>。注意，这里是一个递归序列，</strong>其中di为增量序列，TableSize为散列表长**。<br>根据di的不同我们又可以分为线性探测，平方（二次）探测，随机探测。</p><h4 id="1、线性探测法"><a href="#1、线性探测法" class="headerlink" title="1、线性探测法"></a>1、线性探测法</h4><p>以增量序列 1，2，……，（TableSize -1）进行循环试探下一个存储地址，即di &#x3D; i。</p><p>例：关键码集合为{47,7,29,11,16,92,22,8,3}，散列表表长为11，散列函数为$H(key)&#x3D;key\quad mod\quad 11 $，用线性探测法处理冲突，则散列表为：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE8.png"><br>通过上图，我们会发现计算散列地址时，较多的元素计算出散列地址为7，图中出现了<strong>堆积</strong>（在处理冲突的过程中会出现<strong>非同义词</strong>之间对同一个散列地址争夺的现象，这种现象就称为堆积现象。）的现象，明明还有空间，却都往一个地方挤。堆积地方的冲突会越来越多。</p><h4 id="2、平方探测法"><a href="#2、平方探测法" class="headerlink" title="2、平方探测法"></a>2、平方探测法</h4><p>以增量序列1^2^，-1^2^，2^2^，-2^2^，……，q^2^，-q^2^ 且q ≤ $\frac{TableSize}{2}$进行循环试探下一个存储地址。</p><p>同上一个例子相同，关键码集合、散列表和散列函数均不做改变，用平方探测法处理冲突，则散列表为：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE9.png"><br>我们可以发现平方探测法是跳着寻找位置的，那么就会存在一个问题，假设散列表中还有空间，平方探测(二次探测)就一定能找得到？举个例子说明一下：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE10.png"><br>散列函数为$H(key)&#x3D;key\quad mod\quad 5$，用平方探测来处理冲突。<br>我们假设下一个插入11，则H(11)&#x3D;1，探测序列：1+1&#x3D;2, 1-1&#x3D;0, (1+2^2^) mod 5&#x3D;0, (1-2^2^) mod 5&#x3D;2，(1+3^2^) mod 5&#x3D;0, (1-3^2^) mod 5&#x3D;2, (1+4^2^) mod 5&#x3D;2,$\cdots\cdots$我们可以看到，存放11元素的地址在地址0与地址2之间往复横跳，虽然地址3和地址4位置是有空位，但是却找不到这个空间。<strong>解决方法</strong>：有定理显示，如果散列表长度TableSize是某个$\color{red}{4k+3}$（k是正整数)形式的$\color{red}{素数}$时，平方探测法就可以探查到整个散列表空间。</p><h4 id="3、随机探测法"><a href="#3、随机探测法" class="headerlink" title="3、随机探测法"></a>3、随机探测法</h4><p>以增量序列是伪随机数来进行循环试探下一个存储地址。</p><p>计算机产生随机数的方法通常采用线性同余法，<br>$$ 函数名&#x3D;\begin{cases}<br>a_0&#x3D;d &amp;  \<br>a_n&#x3D;(ba_{n-1}+c);mod;m &amp; n&#x3D;1,2,\cdots \<br>\end{cases}$$<br>其中，d称为随机种子。当b、c和m的值确定后，给定一个随机种子，产生确定的随机数序列。</p><h3 id="2、拉链法（链地址法）"><a href="#2、拉链法（链地址法）" class="headerlink" title="2、拉链法（链地址法）"></a>2、拉链法（链地址法）</h3><p>对于不同的关键字可能会通过散列函数映射到同一地址，为避免非同义词发生冲突，把所有散列地址相同的记录，即所有同义词记录存储在一个线性链表中（称为同义词子表），在散列表中存储的是所有同义词子表的头指针。最开始我们已经说过了，用拉链法处理冲突构造出的散列表叫做<strong>开散列表</strong>。开散列表是不会出现堆积现象的。设n个记录存储在长度为m的散列表中，则同义词子表的平均长度为$\frac{n}{m}$。</p><p>关键字序列为 {15,16,29,37,48,12,25,56,67,47,22,34}，应用拉链法处理冲突的散列表如下图所示：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE11.png"><br>当单链表无法满足查找需求时，或者说单链表过长导致查找效率过低时，我们可以将单链表改成平衡二叉树或者红黑树进行数据的存储和查找，如下图所示：<br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE12.png"></p><h2 id="4、散列查找的性能分析"><a href="#4、散列查找的性能分析" class="headerlink" title="4、散列查找的性能分析"></a>4、散列查找的性能分析</h2><ul><li><p>由于冲突的存在，产生冲突后的查找仍然是给定值与关键码进行比较的过程。</p></li><li><p>在查找过程中，关键码的比较次数取决于产生冲突的概率。影响冲突产生的因素有：<br>（1）散列函数是否均匀<br>（2）处理冲突的方法<br>（3）散列表的装载因子<br>       $$\alpha&#x3D; \frac{表中填入的记录数}{散列表的长度}$$</p></li><li><p>几种处理冲突方法的<strong>平均查找长度（ASL）</strong><br><img src="/2022/11/14/san-lie-biao/%E5%9B%BE13.png"></p><blockquote><p>散列表的平均查找长度是$\color{red}{装填因子\alpha的函数}$，而不是查找集合中记录个数n的函数。在很多情况下，散列表的空间都比查找集合大，此时虽然浪费了一定的空间，但换来的是查找效率。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2022/11/12/hong-hei-shu/"/>
      <url>/2022/11/12/hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>学过了二叉查找树还有平衡二叉树以后，再看点更复杂的树形结构——红黑树，跟平衡二叉树一样，红黑树也是为了解决二叉搜索树不能自平衡的问题。红黑树是2-3树的变形，以2-3树的角度去理解红黑树会容易的多。</p></blockquote><hr><p>先回忆一下AVL树：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE1.png"><br>AVL树就是要保证插入结点后，任一结点对应的两棵子树的最大高度差为1，这样就可以保证整棵树的深度最小。</p><p>AVL虽然高度平衡，但是我们发现它每次插入或者删除结点的时候，树的平衡都可能被打破，而且如果要一直保证也就是动态的来使得这个 AVL 树达到平衡是需要很多操作的，太多步的操作反而会影响这个树形结构的的性能。除非是在树结构变化特别少的情况，不然我们让AVL 树平衡的时候，搜索性能的提升可能还不够抵消平衡树所带来的性能消耗。所以就相继出现了2-3树和红黑树。</p><hr><h2 id="1、2-3树"><a href="#1、2-3树" class="headerlink" title="1、2-3树"></a>1、2-3树</h2><h3 id="1、什么是2-3树"><a href="#1、什么是2-3树" class="headerlink" title="1、什么是2-3树"></a>1、什么是2-3树</h3><p>2-3树的意思就是说，一个父节点可以有两个子结点，也可以有三个子结点，并且其也满足类似二叉搜索树的定义（父结点的值大于左子树，但小于右子树），所有叶子节点都在同一层。</p><p>2-3树的某个节点会有两种可能，一是正常的2节点，二是3节点：</p><ul><li>2节点：父亲节点存储一个值，最多有左右两个子树。假设父节点为p，子节点为l(左节点)、r(有节点)，且满足：<br>$$l &lt; p &lt; r$$<br>如下图：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE2.png"></li><li>3节点：父亲节点存储两个值，最多有左中右三个子树。假设父节点分别为p1,p2，子节点分别为l(左节点)、m(中间节点)、r(右节点)，且满足：<br>$<br>\begin{cases}<br>l &lt; p1\<br>p1 &lt; m &lt; p2\<br>r &gt; p2<br>\end{cases}<br>$<br>如下图：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE3.png"><br>一颗完整的2-3树就如下图所示：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE4.png"></li></ul><h3 id="2、2-3树的创建"><a href="#2、2-3树的创建" class="headerlink" title="2、2-3树的创建"></a>2、2-3树的创建</h3><p>假设有一组数据集合数组为**{ 30, 13, 7, 43, 23, 12, 9, 33, 42, 21, 18, 6, 3, 50 }。**</p><p>创建2-3树的过程：</p><p>1、将30作为根节点<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE5.png"><br>2、插入13，13比30小，融合成一个值为（13  30）的3节点<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE6.png"><br>3、插入7，7比13小，融合成一个值为（7  13  30）的4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE7.png"><br>4、插入43，43大于13，43大于30，与30一起融合成3节点<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE8.png"><br>5、插入23，23大于13，23小于30，与（30  43）融合成4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE9.png"><br>6、插入12，12小于13，12大于7，与7融合成3节点<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE10.png"><br>7、插入9，9小于13，9大于7，9小于12，与（7  12）融合成4节点，然后分解。分解后9升级到上一层，与（13  30）融合成4节点，再次分解<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE11.png"><br>8、插入33，33大于13，33大于30，33小于43，与43融合成3节点<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE12.png"><br>9、插入42，42大于13，42大于30，42大于33，42小于43，与（33  43）融合成4节点，然后分解<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE13.png"><br>10、省略后面过程，最终生成结果为：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE14.png"><br>至此，我们创建了一颗2-3树，可以看出2-3树的平衡性还是很好的。</p><h2 id="2、红黑树"><a href="#2、红黑树" class="headerlink" title="2、红黑树"></a>2、红黑树</h2><hr><blockquote><p>尽管有平衡二叉树和2-3树了，但是现在用的多的还是红黑树，主要是因为红黑树有这4点的优势：<br>1、AVL的左右子树高度差不能超过1，每次进行插入&#x2F;删除操作时，几乎都需要通过旋转操作保持平衡。<br>2、在频繁进行插入&#x2F;删除的场景中，频繁的旋转操作使得AVL的性能大打折扣。<br>3、红黑树通过牺牲严格的平衡，换取插入&#x2F;删除时少量的旋转操作，整体性能优于AVL。（红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决。）<br>4、红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。</p></blockquote><hr><h3 id="1、将2-3树转换成红黑树"><a href="#1、将2-3树转换成红黑树" class="headerlink" title="1、将2-3树转换成红黑树"></a>1、将2-3树转换成红黑树</h3><p>创建了一棵2-3树以后，我们就可以进行一些结构上的变化<br>将所有的3节点进行变换，并且满足三个条件：</p><ul><li>红链接均为左链接。</li><li>没有任何一个节点同时和两条红链接相连。</li><li>任意空链接到根节点路径上的黑色连接数目相同。</li></ul><p>这三个条件均满足以后我们创建的就是一棵不那么标准的红黑树，如下图：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE15.png"></p><h3 id="2、红黑树的性质"><a href="#2、红黑树的性质" class="headerlink" title="2、红黑树的性质"></a>2、红黑树的性质</h3><p>红黑树本身是一棵二叉查找树，在其基础上附加了两个要求：</p><ul><li>树中的每个结点增加了一个用于存储颜色的标志域；</li><li>树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。</li></ul><hr><blockquote><p>路径：指的是从任何一个结点开始，一直到其子孙的叶子结点的长度；<br>接近于平衡：红黑树并不是平衡二叉树，只是由于对各路径的长度之差有限制，所以近似于平衡的状态。</p></blockquote><hr><p>下面图示的就是一棵典型的红黑树：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE16.png"></p><hr><blockquote><p>观察上图，可以发现红黑树的一些规律：<br>1、这些节点<strong>不是红色的就是黑色的</strong>，但是<strong>根节点是黑色的</strong>。<br>2、再看叶子节点，叶子节点跟普通的树不太一样，<strong>红黑树的叶子节点都是null节点（空节点）并且都为黑色的</strong>。<br>3、假设从根节点出发，然后从最左边的路径走到叶子节点，都没有连续的红色节点。所以可以得出一个结论，<strong>同一路径，不存在连续的红色节点</strong>。<br>以上观察出来的这三条规律就是红黑规则的一部分。</p></blockquote><hr><p>因此我们就可以得出红黑树的红黑规则了：</p><ul><li>性质1：每个结点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子结点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li><li>从性质5又可以推出：<br>    性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><h3 id="3、红黑树的术语约定"><a href="#3、红黑树的术语约定" class="headerlink" title="3、红黑树的术语约定"></a>3、红黑树的术语约定</h3><p><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE17.png"><br>正在遍历的结点称做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做叔叔结点，父亲的父亲叫做祖父结点。</p><h3 id="4、红黑树基本操作"><a href="#4、红黑树基本操作" class="headerlink" title="4、红黑树基本操作"></a>4、红黑树基本操作</h3><blockquote><p>$\color{red}{红黑树总是通过旋转和变色达到自平衡}$</p></blockquote><p>1、左旋<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE18.gif"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void left_rotate(RBT_Node* x) &#x2F;&#x2F;x 表示需要进行左旋的子树的根结点&#123;RBT_Node* y &#x3D; x-&gt;right_Child;  &#x2F;&#x2F;找到根节点的右子树    x-&gt;right_Child &#x3D; y-&gt;left_Child;  &#x2F;&#x2F;将右子树的左孩子移动至节点x的右孩子处            &#x2F;&#x2F;y所指结点的左结点不为空    if (y-&gt;left_Child !&#x3D; nil)    &#123;    y-&gt;left_Child-&gt;parent &#x3D; x;&#125;    y-&gt;parent &#x3D; x-&gt;parent;  &#x2F;&#x2F;设置y的双亲结点为x的双亲节点            &#x2F;&#x2F;判断x节点是不是其父节点的左右子树    if (x-&gt;parent &#x3D;&#x3D; nil)    &#123;root &#x3D; y;&#125;else if (x-&gt;parent-&gt;left_Child &#x3D;&#x3D; x)&#x2F;&#x2F;x在左子树    &#123;x-&gt;parent-&gt;left_Child &#x3D; y;&#125;    else  &#x2F;&#x2F;x在右子树    &#123;    x-&gt;parent-&gt;right_Child &#x3D; y;    &#125;    x-&gt;parent &#x3D; y;    y-&gt;left_Child &#x3D; x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、右旋<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE19.gif"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;右旋操作（与左子树操作基本相同）void right_rotate(RBT_Node* x)&#123;RBT_Node* y &#x3D; x-&gt;left_Child;x-&gt;left_Child &#x3D; y-&gt;right_Child;if (y-&gt;right_Child !&#x3D; nil)&#123;y-&gt;right_Child-&gt;parent &#x3D; x;&#125;y-&gt;parent &#x3D; x-&gt;parent;if (x-&gt;parent &#x3D;&#x3D; nil)&#123;root &#x3D; y;&#125;else if (x-&gt;parent-&gt;left_Child &#x3D;&#x3D; x)&#123;x-&gt;parent-&gt;left_Child &#x3D; y;&#125;else&#123;x-&gt;parent-&gt;right_Child &#x3D; y;&#125;x-&gt;parent &#x3D; y;y-&gt;right_Child &#x3D; x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE20.png"></p><p>3、变色</p><p>结点的颜色由红变黑或由黑变红。</p><h3 id="5、红黑树的插入"><a href="#5、红黑树的插入" class="headerlink" title="5、红黑树的插入"></a>5、红黑树的插入</h3><blockquote><p>在创建红黑树或者向已有红黑树中添加新的数据时，其实我们只需要按部就班地执行以下3 步操作：<br>1、由于红黑树本身是一棵二叉查找树，所以在插入新的结点时，完全按照二叉查找树插入结点的方法，找到新结点插入的位置；<br>2、将新插入的结点结点初始化，颜色设置为红色后插入到指定位置；（将新结点初   始化为红色插入后，不会破坏红黑树第 5 条的性质）<br>3、由于插入新的结点，可能会破坏红黑树第 4 条的性质（若其父结点颜色为红色，就破坏了红黑树的性质），此时需要调整二叉查找树，想办法通过旋转以及修改树中结点的颜色，使其重新成为红黑树！</p></blockquote><p>第一步和第二步都比较容易，与二叉查找树差不多，最麻烦的就是第三步对树的调整。在红黑树中插入结点时，根据插入位置的不同可分为以下 3 种情况，前两种都比较简单：</p><p>第一种，插入位置为整棵树的树根。处理办法：只需要将插入结点的颜色改为黑色即可。</p><p>第二种：如果插入位置的双亲结点的颜色为黑色。处理方法：此种情况不需要做任何工作，新插入的颜色为红色的结点不会破坏红黑树的性质。</p><p>第三种情况就麻烦了，插入位置的双亲结点的颜色为红色。同样的，我们也有相对应的处理方法：因为插入结点颜色为红色，并且双亲结点也是红色的，所以破坏了红黑树第 4 条性质，那么这个时候就需要结合其祖父结点和祖父结点的另一个孩子结点（即叔叔结点）的状态，在这里我们又要分成 3 种情况来讨论：</p><p>1、当前结点的父节点是红色，且“叔叔结点”也是红色，所以破坏了红黑树的第 4 条性质。此时的解决方案就是：我们将父结点颜色改为黑色；将叔叔结点颜色改为黑色；再将祖父结点颜色改为红色；下一步将祖父结点认做当前结点，继续判断，处理结果如下图所示：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE21.png"><br>分析：此种情况下，由于父结点和当前结点颜色都是红色，所以为了不产生冲突，将父结点的颜色改为黑色。但是虽避免了破坏第 4 条，但是却导致该条路径上的黑高度增加了 1 ，破坏了第 5 条性质。但是在将祖父结点颜色改为红色、叔叔结点颜色改为黑色后，该部分子树没有破坏第 5 条性质。但是由于将祖父结点的颜色改变，还需判断是否破坏了上层树的结构，所以需要将祖父结点看做当前结点，继续判断。</p><p>2、当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的右孩子。解决方案：将父结点作为当前结点做左旋操作。<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE22.png"><br>在进行以父结点为当前结点的左旋操作后，此种情况就转变成了第 3 种情况，处理过程跟第 3 种情况同步进行。</p><p>3、当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的左孩子。解决方案：将父结点颜色改为黑色，祖父结点颜色改为红色，从祖父结点处进行右旋处理。如下图所示：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE23.png"><br>分析：在此种情况下，由于当前结点 F 和父结点 S 颜色都为红色，违背了红黑树的性质 4，此时可以将 S 颜色改为黑色，又违反了性质 5，因为所有通过 S 的路径其黑高度都增加了 1 ，所以需要将其祖父结点颜色设为红色后紧接一个右旋，这样这部分子树有成为了红黑树。（上图中的右图虽看似不是红黑树，但是只是整棵树的一部分，以 S 为根结点的子树一定是一棵红黑树)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RBT_Node* Insert_BST(RBT_Node*&amp; p, RBT_Node*&amp; r, const int&amp; v)&#123;if (r &#x3D;&#x3D; nil)&#123;&#x2F;&#x2F;数为空r &#x3D; new RBT_Node(v, RED, nil, nil, p);if (p &#x3D;&#x3D; nil)&#123;root &#x3D; r;&#125;if (v &gt; p-&gt;val)  &#x2F;&#x2F;插入的节点键值小于父节点的键值&#123;p-&gt;right_Child &#x3D; r;  &#x2F;&#x2F;则该节点成为父节点右孩子&#125;else&#123;p-&gt;left_Child &#x3D; r;  &#x2F;&#x2F;则该节点成为父节点右孩子&#125;&#125;&#x2F;&#x2F;若不为空，则一直搜索直至找到空else&#123;if (v &lt; r-&gt;val)&#123;return Insert_BST(r,r-&gt;left_Child, v);  &#x2F;&#x2F;利用递归进行调用&#125;else&#123;return Insert_BST(r,r-&gt;right_Child, v);&#125;&#125;return r;&#125;&#x2F;&#x2F;插入后的调整函数void insert(const int&amp; v)&#123;RBT_Node* z &#x3D; Insert_BST(nil, root, v);&#x2F;&#x2F;首先判断其父节点颜色为红色时才需要调整；为黑色时直接插入即可，不需要调整while (z-&gt;parent-&gt;color &#x3D;&#x3D; RED)  &#x2F;&#x2F;父节点的颜色为红色&#123;&#x2F;&#x2F;由于还涉及到其叔叔节点，所以此处需分开讨论，确定父节点是祖父节点的左孩子还是右孩子if (z-&gt;parent-&gt;parent-&gt;left_Child &#x3D;&#x3D; z-&gt;parent)  &#x2F;&#x2F;父节点是左节点&#123;&#x2F;&#x2F;叔节点为红色if (z-&gt;parent-&gt;parent-&gt;right_Child-&gt;color &#x3D;&#x3D; RED)  &#123;&#x2F;*如果叔叔结节点颜色为红色，此为第 1 种情况，处理方法为：父节点颜色改为黑色；叔叔节点颜色改为黑色；祖父节点颜色改为红色，将祖父节点赋值为当前结点，继续判断；*&#x2F;z-&gt;parent-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;父节点z-&gt;parent-&gt;parent-&gt;right_Child-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;叔节点z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;  &#x2F;&#x2F;祖父节点z &#x3D; z-&gt;parent-&gt;parent;  &#125;&#x2F;*反之，如果叔叔节点颜色为黑色，此处需分为两种情况：1、当前节点是父节点的右孩子；2、当前节点是父节点的左孩子*&#x2F;else&#123;&#x2F;*当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的右孩子。解决方案：将父节点作为当前节点做左旋操作。*&#x2F;if (z-&gt;parent-&gt;right_Child &#x3D;&#x3D; z)&#123;z &#x3D; z-&gt;parent;left_rotate(z);&#125;&#x2F;*当前节点的父节点颜色为红色，叔叔节点颜色为黑色，且当前节点是父节点的左孩子。解决方案：将父节点颜色改为黑色，祖父节点颜色改为红色，从祖父节点处进行右旋处理。*&#x2F;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;right_rotate(z-&gt;parent-&gt;parent);&#125;&#125;            &#x2F;*如果父节点时祖父节点的右孩子只需将以上代码部分中的left改为right即可，道理是一样的。*&#x2F;else&#123;if (z-&gt;parent-&gt;parent-&gt;left_Child-&gt;color &#x3D;&#x3D; RED)&#123;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;z-&gt;parent-&gt;parent-&gt;left_Child-&gt;color &#x3D; BLACK;z &#x3D; z-&gt;parent-&gt;parent;&#125;else&#123;if (z-&gt;parent-&gt;left_Child &#x3D;&#x3D; z)&#123;z &#x3D; z-&gt;parent;right_rotate(z);&#125;z-&gt;parent-&gt;color &#x3D; BLACK;z-&gt;parent-&gt;parent-&gt;color &#x3D; RED;left_rotate(z-&gt;parent-&gt;parent);&#125;&#125;&#125;root-&gt;color &#x3D; BLACK;  &#x2F;&#x2F;将根节点的颜色设置为黑色&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、红黑树的删除"><a href="#6、红黑树的删除" class="headerlink" title="6、红黑树的删除"></a>6、红黑树的删除</h3><blockquote><p>删除节点要比插入节点简单一点，在红黑树中删除结点，只需要完成 2 步操作：<br>1、将红黑树按照二叉查找树删除结点的方法删除指定结点；<br>2、重新调整删除结点后的树，使之重新成为红黑树；（还是通过旋转和重新着色的方式进行调整）</p></blockquote><p>在树删除结点的时候，又要分为 3 种情况：</p><p>第一种：若该删除结点本身是叶子结点，则可以直接删除；</p><p>第二种：若只有一个孩子结点（左孩子或者右孩子），则直接让其孩子结点顶替该删除结点；</p><p>第三种：若有两个孩子结点，则找到该结点的右子树中值最小的叶子结点来顶替该结点，然后删除这个值最小的叶子结点。</p><p>以上这三种情况最终都需要删除某个结点，所以我们此时需要判断删除该结点是否会破坏红黑树的性质。判断的依据是：</p><ul><li>如果删除结点的颜色为红色，则不会破坏；</li><li>如果删除结点的颜色为黑色，则肯定会破坏红黑树的第 5 条性质，此时就需要对树进行调整，调整方案又分成4种情况讨论：</li></ul><p>1、删除结点的兄弟结点颜色是红色，调整措施为：将兄弟结点颜色改为黑色，父亲结点改为红色，以父亲结点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后兄弟结点发生了变化），如下图所示：<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE24.png"><br>2、删除结点的兄弟结点及其孩子全部都是黑色的，调整措施为：将删除结点的兄弟结点设为红色，同时设置删除结点的父结点标记为新的结点，继续判断；</p><p>3、删除结点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟结点设为红色，兄弟结点的左孩子结点设为黑色，以兄弟结点为准进行右旋操作，最终更新删除结点的兄弟结点；</p><p>4、删除结点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除结点的父结点的颜色赋值给其兄弟结点，然后再设置父结点颜色为黑色，兄弟结点的右孩子结点为黑色，根据其父结点做左旋操作，最后设置替换删除结点的结点为根结点；</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void RBT_Transplant(RBT_Node*&amp; u, RBT_Node*&amp; v)&#123;    if (u-&gt;parent &#x3D;&#x3D; nil)    &#123;        root &#x3D; v;    &#125;    else if (u &#x3D;&#x3D; u-&gt;parent-&gt;left_Child)    &#123;        u-&gt;parent-&gt;left_Child &#x3D; v;    &#125;    else    &#123;        u-&gt;parent-&gt;right_Child &#x3D; v;    &#125;    v-&gt;parent &#x3D; u-&gt;parent;&#125;&#x2F;&#x2F;删除节点void Delete_RBT(RBT_Node* z)&#123;    RBT_Node* y &#x3D; z;    bool delcol &#x3D; y-&gt;color;    RBT_Node* x &#x3D; z;    &#x2F;*如果只有一个孩子结点（只有左孩子或只有右孩子），    直接用孩子结点顶替该结点位置即可（没有孩子结点的也走此判断语句）。*&#x2F;    if (z-&gt;left_Child &#x3D;&#x3D; nil)    &#123;        x &#x3D; z-&gt;right_Child;        RBT_Transplant(z, z-&gt;right_Child);    &#125;    else if (z-&gt;right_Child &#x3D;&#x3D; nil)    &#123;        x &#x3D; z-&gt;left_Child;        RBT_Transplant(z, z-&gt;left_Child);    &#125;    &#x2F;&#x2F;如果两个孩子，就找到右子树中最小的结点，将之代替，然后直接删除该结点即可    else    &#123;        y &#x3D; Find_min(z-&gt;right_Child);        delcol &#x3D; y-&gt;color;        x &#x3D; y-&gt;right_Child;        if (y-&gt;parent &#x3D;&#x3D; z)        &#123;            x-&gt;parent &#x3D; y;        &#125;        else        &#123;            RBT_Transplant(y, y-&gt;right_Child);            y-&gt;right_Child &#x3D; z-&gt;right_Child;            y-&gt;right_Child-&gt;parent &#x3D; y;        &#125;        RBT_Transplant(z, y);        y-&gt;left_Child &#x3D; z-&gt;left_Child;        y-&gt;left_Child-&gt;parent &#x3D; y;        y-&gt;color &#x3D; z-&gt;color;    &#125;    &#x2F;*在删除该结点之前，需判断此结点的颜色：如果是红色，直接删除，不会破坏红黑树；    若是黑色，删除后会破坏红黑树的第 5 条性质，需要对树做调整。*&#x2F;    if (delcol &#x3D;&#x3D; BLACK)    &#123;        Delete_Fixup_RBT(x);    &#125;&#125;void Delete_RBT(const int&amp; v)&#123;    RBT_Node* z &#x3D; Get_Node(root, v);    if (z &#x3D;&#x3D; nil)    &#123;        return;    &#125;    Delete_RBT(z);&#125;&#x2F;&#x2F;删除后调整树节点void Delete_Fixup_RBT(RBT_Node* x)&#123;    while (x !&#x3D; root &amp;&amp; x-&gt;color &#x3D;&#x3D; BLACK)    &#123;        if (x &#x3D;&#x3D; x-&gt;parent-&gt;left_Child)        &#123;            RBT_Node* w &#x3D; x-&gt;parent-&gt;right_Child;            &#x2F;*第 1 种情况：删除节点的兄弟节点颜色是红色。            解决方案为：将兄弟节点颜色改为黑色，父亲节点改为红色，以父亲节点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后 兄弟结点发生了变化）*&#x2F;            if (w-&gt;color &#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; BLACK;                x-&gt;parent-&gt;color &#x3D; RED;                left_rotate(x-&gt;parent);                w &#x3D; x-&gt;parent-&gt;right_Child;            &#125;            &#x2F;*第2种情况：删除节点的兄弟节点及其孩子全部都是黑色的。            解决方案为：将删除节点的兄弟结点设为红色，同时设置删除节点的父节点标记为新的结点，继续判断*&#x2F;            if (w-&gt;left_Child-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; w-&gt;right_Child-&gt;color&#x3D;&#x3D; BLACK)            &#123;                w-&gt;color &#x3D; RED;                x &#x3D; x-&gt;parent;            &#125;            else            &#123;                &#x2F;*第3种情况：删除节点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。                解决方案为：将兄弟节点设为红色，兄弟节点的左孩子结点设为黑色，以兄弟节点为准进行右旋操作，最终更新删除结点的兄    弟节点*&#x2F;                if (w-&gt;right_Child-&gt;color &#x3D;&#x3D; BLACK)                &#123;                    w-&gt;left_Child-&gt;color &#x3D; BLACK;                    w-&gt;color &#x3D; RED;                    right_rotate(w);                    w &#x3D; x-&gt;parent-&gt;right_Child;                &#125;                &#x2F;*第4种情况：删除节点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色）                解决方案为：将删除节点的父节点的颜色赋值给其兄弟节点，然后再设置父节点颜色为黑色，兄弟节点的右孩子节点为黑色，    根据其父节点做左旋操作，最后设置替换删除节点的结点为根结点；将删除节点的父节点的颜色赋值给其兄弟节点，然后再设    置父节点颜色为黑色，兄弟节点的右孩子节点为黑色，根据其父节点做左旋操作，最后设置替换删除节点的结点为根节点*&#x2F;                w-&gt;color &#x3D; x-&gt;parent-&gt;color;                x-&gt;parent-&gt;color &#x3D; BLACK;                w-&gt;right_Child-&gt;color &#x3D; BLACK;                left_rotate(x-&gt;parent);                x &#x3D; root;            &#125;        &#125;        else        &#123;            RBT_Node* w &#x3D; x-&gt;parent-&gt;left_Child;            if (w-&gt;color &#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; BLACK;                x-&gt;parent-&gt;color &#x3D; RED;                right_rotate(x-&gt;parent);                w &#x3D; x-&gt;parent-&gt;left_Child;            &#125;            if (w-&gt;right_Child-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; w-&gt;left_Child-&gt;color&#x3D;&#x3D; RED)            &#123;                w-&gt;color &#x3D; RED;                x &#x3D; x-&gt;parent;            &#125;            else            &#123;                if (w-&gt;left_Child-&gt;color &#x3D;&#x3D; BLACK)                &#123;                    w-&gt;right_Child-&gt;color &#x3D; BLACK;                    w-&gt;color &#x3D; RED;                    left_rotate(w);                    w &#x3D; x-&gt;parent-&gt;left_Child;                &#125;                w-&gt;color &#x3D; x-&gt;parent-&gt;color;                x-&gt;parent-&gt;color &#x3D; BLACK;                w-&gt;left_Child-&gt;color &#x3D; BLACK;                right_rotate(x-&gt;parent);                x &#x3D; root;            &#125;        &#125;    &#125;    x-&gt;color &#x3D; BLACK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、红黑树的应用"><a href="#6、红黑树的应用" class="headerlink" title="6、红黑树的应用"></a>6、红黑树的应用</h3><p>1、散列表的冲突处理<br>map的实现，底层一般会采用红黑树，在节点多的时候效率高。<br>在节点少的时候，可用链表方式。<br><img src="/2022/11/12/hong-hei-shu/%E5%9B%BE25.png"><br>2、动态插入、删除和查询较多的场景</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 2-3树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径(Dijkstra算法)</title>
      <link href="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/"/>
      <url>/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>Dijkstra算法刚接触时确实有点难以理解，尤其是代码的实现，但其背后的逻辑实际上是用贪心算法来支撑的。但是在算法学习中Dijkstra算法又是最基本的一种算法，对于求解单源最短路径有着极大的作用。在这里我简单讲一下自己的理解，我的代码参考了《图解数据结构》，该代码适合稠密图，使用的是邻接矩阵来存储的图。 </p></blockquote><hr><h2 id="1、Dijkstra算法主要步骤"><a href="#1、Dijkstra算法主要步骤" class="headerlink" title="1、Dijkstra算法主要步骤"></a>1、Dijkstra算法主要步骤</h2><p><img src="/2021/11/12/zui-duan-lu-jing-dijkstra-suan-fa/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4.png"></p><p>对于贪心算法，简单描述一下：<br>贪心算法正如其名字一样，贪心算法只注重眼前利益，就像贪心的小人一样，因此得名贪心算法，该算法即从一个初始解，一步步选取当前最优解，最终得出近似的最优解（注意：不一定是该问题的最优解，而是近似于最优解）。<br>实现该算法的基本过程如下。<br>（1）从问题的某一初始解出发。<br>（2）while能向给定总目标前进一步。<br>（3）求出可行解的一个解元素。<br>（4）由所有解元素组合成问题的一个可行解。<br>（想更深入了解请参考链接<a href="https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187%EF%BC%89">https://blog.csdn.net/effective_coder/article/details/8736718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164621206116781685343755%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164621206116781685343755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-8736718.pc_search_result_control_group&amp;utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187）</a></p><hr><h2 id="2、Dijkstra算法小结"><a href="#2、Dijkstra算法小结" class="headerlink" title="2、Dijkstra算法小结"></a>2、Dijkstra算法小结</h2><p> 1、Dijkstra算法一般是用来解决单源最短路径问题（指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。）<br> 2、其时间复杂度仅为O(n^2^)，并且非常高效，甚至可以优化成O(log2n)。<br> 3、Dijkstra算法中权值只能为正数，若权值为负数则不能使用该算法。（权值即图各个边所赋予的值）  </p><hr><h2 id="3、算法实现"><a href="#3、算法实现" class="headerlink" title="3、算法实现"></a>3、算法实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; #define SIZE 7#define NUMBER 6#define INFINITE 123456  &#x2F;&#x2F;宏定义无穷大 &#x2F;&#x2F;首先定义图的数组int Graph_Matrix[SIZE][SIZE];int Distance[SIZE];  &#x2F;&#x2F;路径长度 &#x2F;&#x2F;建立有向图void Create_Graph(int *Path_Cost)&#123;    int i,j;    for(i&#x3D;0;i&lt;SIZE;i++)    &#123;        for(j&#x3D;0;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;若是在对角线上，设置元素值为0            if(i&#x3D;&#x3D;j)            &#123;                Graph_Matrix[i][j]&#x3D;0;            &#125;            &#x2F;&#x2F;其他位置元素的值为无穷大            else            &#123;                Graph_Matrix[i][j]&#x3D;INFINITE;            &#125;        &#125;    &#125;     int End_Point,Start_Point;  &#x2F;&#x2F;图的边起始位置和终止位置     &#x2F;&#x2F;存入图的各个数据：边，权重    i&#x3D;0;    while(i&lt;SIZE)    &#123;        Start_Point&#x3D;Path_Cost[i*3];  &#x2F;&#x2F;在邻接矩阵中的行        End_Point&#x3D;Path_Cost[i*3+1];  &#x2F;&#x2F;在邻接矩阵中的列        &#x2F;&#x2F;图各边权值转化为邻接矩阵中所在的位置        Graph_Matrix[Start_Point][End_Point]&#x3D;Path_Cost[i*3+2];        i++;    &#125;&#125; &#x2F;&#x2F;打印邻接矩阵void Print_Matrix()&#123;    int i&#x3D;0,j&#x3D;0;    for(i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;vex&quot; &lt;&lt; i ;        for(j&#x3D;1;j&lt;SIZE;j++)        &#123;            &#x2F;&#x2F;为了美观和可读性，将值为无穷大的元素打印为x            if(Graph_Matrix[i][j]&#x3D;&#x3D;INFINITE)            &#123;                cout &lt;&lt; setw(5) &lt;&lt; &quot;x&quot;;            &#125;            else            &#123;                cout &lt;&lt; setw(5) &lt;&lt; Graph_Matrix[i][j];            &#125;        &#125;        cout &lt;&lt; endl;    &#125;&#125; &#x2F;&#x2F;开始求解单源最短路径void Shortest_Path(int vertex1,int vertex_total)&#123;    int Shortest_vertex&#x3D;1;  &#x2F;&#x2F;初始化    int Shortest_distance;  &#x2F;&#x2F;最短距离    int flag[SIZE];  &#x2F;&#x2F;标志数组，标志顶点是否已经遍历过    int i,j;     for(i&#x3D;1;i&lt;&#x3D;vertex_total;i++)    &#123;        flag[i]&#x3D;0;  &#x2F;&#x2F;初始化标志数组        Distance[i]&#x3D;Graph_Matrix[vertex1][i];  &#x2F;&#x2F;将图的权值存入Distance[]数组中    &#125;     flag[vertex1]&#x3D;1;  &#x2F;&#x2F;标志该顶点已经找过    Distance[vertex1]&#x3D;0;  &#x2F;&#x2F;顶点到该顶点自身的距离为0     for(i&#x3D;0;i&lt;&#x3D;vertex_total-1;i++)    &#123;        Shortest_distance&#x3D;INFINITE;        for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;找到最小权边的顶点            if(flag[j]&#x3D;&#x3D;0 &amp;&amp; Distance[j]&lt;&#x3D;Shortest_distance)            &#123;                Shortest_distance&#x3D;Distance[j];                Shortest_vertex&#x3D;j;            &#125;        &#125;         flag[Shortest_vertex]&#x3D;1;  &#x2F;&#x2F;找到下一个顶点后标记为已经经过         for(j&#x3D;0;j&lt;&#x3D;vertex_total;j++)        &#123;            &#x2F;&#x2F;以上一个顶点为父节点，若前一个顶点和下一个权边的和最小，则更新最短路径            if(flag[j]&#x3D;&#x3D;0 &amp;&amp;               Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j]               &lt;Distance[j])            &#123;                &#x2F;&#x2F;更新最短路径                Distance[j]&#x3D;Distance[Shortest_vertex]+Graph_Matrix[Shortest_vertex][j];            &#125;        &#125;    &#125;&#125; int main()&#123;    int Path_Cost[9][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;1,3,5&#125;,&#123;1,4,1&#125;,&#123;1,5,3&#125;,&#123;1,6,4&#125;,                         &#123;2,5,3&#125;,&#123;4,5,7&#125;,&#123;4,6,6&#125;,&#123;4,3,2&#125;&#125;;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;此范例图的邻接矩阵如下：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;顶点   vex1 vex2 vex3 vex4 vex5 vex6&quot; &lt;&lt; endl;    Create_Graph(&amp;Path_Cost[0][0]);    Print_Matrix();    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    cout &lt;&lt; &quot;顶点1到各顶点最短距离的最终结果&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  &lt;&lt; endl;    &#x2F;&#x2F;查找最短路径    Shortest_Path(1,NUMBER);    for(int i&#x3D;1;i&lt;SIZE;i++)    &#123;        cout &lt;&lt; &quot;顶点1&quot; &lt;&lt; &quot;到顶点&quot; &lt;&lt; i &lt;&lt; &quot;的最短距离&#x3D;&quot; &lt;&lt; Distance[i] &lt;&lt; endl;    &#125;     system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人生海海》读后感</title>
      <link href="/2021/05/01/ren-sheng-hai-hai-du-hou-gan/"/>
      <url>/2021/05/01/ren-sheng-hai-hai-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<p><font size="6">　　　　“回首向来萧瑟处，也无风雨也无晴”</font><br><font size="5">　　　　　　　　　　　　　　　　　　　　　——《人生海海》读后感</font></p><p>　　看完《人生海海》，不知道为什么有一种强烈的欲望想要写一篇读后感。人生海海来自于闽南方言，也许是看到人生海海这个书名而对写读后感有一丝冲动。本来我一直以为这本书是作者麦家的自传，直到查了度娘我才死心。想来也是，什么人才能拥有上校一样的人生呢？经历战乱而独善其身，横跨时代而名声依旧，偏居一隅却众望所归。<br>　　生活，不是我们该活过的样子，而是我们该记住的样子。人生百态，世态万千，我觉得人不必活到多么令人高不可攀的境界，也不需要奢求自己活到多么仰望不及的高度，但至少能尽量做到一个有本事有担当且睿智的人。不管天大的事都要觉得不足为惧，凡事看得淡，却又不随波逐流，有自己的一些想法，有自己做事的方式，不浮夸，不张扬，不急不躁。心有雷霆面若静湖，这是生命的厚度，是沧桑堆积起来的。 “人生海海，潮落之后是潮起，你说那是消磨，笑柄，罪过，可那就是我的英雄主义。”<br>　　麦家在书中写道：“人要学会放下，放下是一种饶人的善良，也是饶过自己的智慧。”世界很宽阔，可是人心却很狭窄，能装下的东西太少了，一不小心就满了，所以需要常常清理一下。被执念困扰，因为愧疚自杀的“爷爷”，因爱生恨的林护士，执着到成疯子的上校哪一个不是痛苦不已。所谓放下，也是跟自己和解，原谅自己的一个过程。看看回到孩童智商的上校和为爱守护上校的林护士，又何尝不是一种放下呢？“人生海海，我们像海滩上的两粒沙一样相遇。”<br>　　“人生海海，敢死不叫勇气，活着才需要勇气。有人说人出生是不平等的，而在这世界上唯一平等的只有死亡，我认为这个见解十分中肯。但死去不是人生目标，而只是人生中的一部分。活着才更需要勇气，为了活着，也许我们慢慢学会伪装，变得八面玲珑；也或许我们会活得自我。<br>　　在我看来，人的一生总是按照既定轨迹发展。我记得曾经看视频时，复旦大学的王德峰教授说过的一句话我至今仍然记得，“人到四十岁，还是信力不信命，那只能说明此人悟性太差。”<br>　　而我理解的命运既无关乎鬼神，也无关宗教，我认为它是一种微妙的平衡：财富平衡，健康平衡，幸福感平衡，得失平衡。用科学来解释就是能量守恒，有得必有失，这是我这几年明白的一个道理。当你得到一些东西的时候，不要得意忘形，因为也许你会为之失去很多。生活阴差阳错，我被生活推着向前，身不由己，却甘之如饴。我知道天地为炉，世间万物，芸芸众生，都在煎熬之中。我知道，人世间有很多苦难，没有公平可言，让人摸不着头脑。<br>　　可是既然生活选择了我们，我们也选择了生活，就要放平心态，好好生活。命运没有给我们安排一夜暴富得“幸运”，也不会给我们安排跨越不过得“霉运”。顺境时，不卑不亢，且待风落；逆境时，不卑不亢，且待风起。“命里有时终须有，命里无时莫强求”。<br>　　世上只有一种英雄主义，就是看清了生活的本质后，依然热爱生活。<br>　　生活从来不完美，不完美才是生活。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树(Kruskal算法)</title>
      <link href="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/"/>
      <url>/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>一下子就接触算法原理和一堆七七八八的术语概念，无疑是让人头疼的，因为无端出现这么多的信息，都不知道它的来历，又不知道这些信息到底有什么用，所以我们就从最简单的内容开始，将这个算法完整地梳理一下吧。</p></blockquote><hr><h2 id="1、知识脉络梳理"><a href="#1、知识脉络梳理" class="headerlink" title="1、知识脉络梳理"></a>1、知识脉络梳理</h2><h3 id="1、树形结构"><a href="#1、树形结构" class="headerlink" title="1、树形结构"></a>1、树形结构</h3><p>首先，先来看看一个简单的数据结构——树。<br>树形结构，从字面上来理解，就是像我们生活中常见的树长的很类似。在数据结构中我们无非就是将生活中的树倒过来看而已，也就是树根在上，树叶在下。这么设计其实也没什么特别的道理，只是在遍历树的时候，我们从树根开始，从树根往叶子节点出发。但是除了倒着放，其实我们也可以将他伸展开来放，例如下面的这棵树，其实也是一棵树</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE1.png"></p><p>我们大致的想象一下，就像直接抓着树根将它拎起来，那么就自然变成了上图的样子了。</p><p>于是我们就发现，不管拎起是哪个节点，都会得到一棵树。也就是说，如果树根的位置对我们不再重要的话，树其实就等价于上面这样的图。</p><p>那么这样的图究竟是什么图呢？它有什么性质呢？所有的图都能看成是树吗？下面我们来看一下三种情况：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE2.png"></p><p>显然这三种情况<strong>都不是树</strong>。第一种是因为图中的边有方向了，一旦有了方向，图中连通的情况就被破坏了。我们都知道，树应该是全部连通的，也就是说你从任意一个节点开始，都可以走到树上任何位置。那么根据定义，<strong>不能全连通，肯定就不是树</strong>。情况2也不对，因为<strong>有了环</strong>，树是不应该有环的，大家应该没见过那种从树根还能再到树根的树吧，那不是成了老树精了？在我们定义中的树也是<strong>不能有环</strong>的，不然我们遍历的时候不是永远也找不到终点了吗？第三种情况则是因为有个别的点孤立在外，因此<strong>不能连通</strong>，所以也不是树。</p><p>所以总结一下，树就是可以全连通的（无向图），并且没有环的图。</p><h3 id="2、从图到树"><a href="#2、从图到树" class="headerlink" title="2、从图到树"></a>2、从图到树</h3><p>从上面的部分，其实我们可以发现，<strong>树的本质就是图</strong>，无非就是一些具有特殊性质的图。因此我们也经常能看到许多有关于树的算法会被纳入图论当中。</p><p>通过对树的观察，其实我们可以发现一条重要性质，对于一棵拥有n个节点的树而言，它会有n-1条边。因此如果超过n-1条边，证明当中一定存在环路，如果不理解的话，你可以简单画个图尝试一下。反之，如果小于n-1条边，那么一定存在不连通的部分。但我们需要注意，这个性质正向可以成立，反过来就不成立了，用数学中的概念来说就是，它是一个必要条件，但不是一个充分条件。也就是说并不是n个点和n-1条边就一定是树，这个画个图就很容易得出反例。</p><p>接下来我们就用这个性质来尝试解决一下由图转化成树的问题。</p><p>现在有一个稍微复杂的图，如下图：<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE3.png"><br>那么我们现在就根据这一个图生成一棵能够连通所有节点的树。根据上述的性质，我们的方法很明确，无非就是两种办法：</p><p>第一种办法是删边，既然是一个复杂图，说明边的数量肯定要超过n-1的，所以我们可以尝试去删减掉一些边，最后留下一棵树就可以了。</p><p>第二种做法则是增边，也就是说我们从零开始，一开始先把所有的边全部撤掉，然后一条一条地往一个集合当中添加n-1条边，让它变成一棵树。</p><p>那这两种方法哪种更好呢？我们可以想一下，我们每一次在删除边的时候是不是都需要考虑到<strong>是否会破坏树的连通关系</strong>，因此添加边的做法明显优于删减边的做法。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE4.png"></p><p>可以看看上图，如果我们删除AB这条边，就会发现这个已经不是连通图了，那必然也不可能成为一棵树。要判断连通关系，最好的方法就是先删除这条边，然后试着从A点出发，看看能否到达B点，如果能到达，则认为这条边是可以删除的，但是如果这么做的话，一旦图很大时，<strong>每一次删除需要遍历整张图</strong>，那么效率就会很低。并且每一次删除后，由于图的结构会发生 变化，我们还需要对这些变化进行存储，但由于他是一直动态变化，存储这些结果十分困难。</p><p>因此，删除边的方式可行，但是十分麻烦。</p><p>至此，我们知道了其实所谓的最小生成树就是从一个图当中选取n-1条边将他变换为一棵树的算法</p><h3 id="3、生成树"><a href="#3、生成树" class="headerlink" title="3、生成树"></a>3、生成树</h3><p>我们暂且不考虑带权问题，就先假设所有的边都是等权重的。</p><p>那么现在我们知道要采用添加边的方式，那我们选择一条边时，应该怎么判断这条有没有必要添加到集合中去呢？</p><p>树有一条性质是，树上任意的两个点，它们之间的路径有且只有一条，如果存在两点之间的路径有两条，那么必然可以形成一个环。那么我们就可以知道如果当前两个点之间已经存在通路的时候，就证明那么当前这两个点连成的边就不能再添加了，否则一定会出现环。因此我们需要设计的算法要<strong>维护树上点的连通性</strong>。</p><p>但是这又会有一个新问题，我们知道，在树结构当中，<strong>连通性是可以传递的</strong>。如果两个点之间连了一条边，并不仅仅只是这两个点连通，还包括了所有与这两个点之间连通的点都连通了。下面来看一个例子：</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE5.png"></p><p>这张图当中A和B连了一条边，这不仅仅是A和B连通，而是<strong>左半边的集合和右半边集合的连通</strong>。所以，虽然A只是和B连通了，但是和C也连通了。AC这条边也一样不能被加入了。也就是说A和B连通，其实是<strong>A所在的集合和B所在的集合合并</strong>的过程。看到集合的合并我们就可以想到并查集，并查集算法就是用来解决集合合并和查询问题的。那么，显然可以用并查集来维护图中这些点集的连通性。关于并查集，如果不知道的朋友可以点击一下<a href="https://blog.csdn.net/bjweimengshu/article/details/108332389">传送门</a>进行了解。</p><p>所以，我们现在就得到了生成树。</p><h3 id="4、从生成树到最小生成树"><a href="#4、从生成树到最小生成树" class="headerlink" title="4、从生成树到最小生成树"></a>4、从生成树到最小生成树</h3><p>现在我们就可以为图中的每条边都加上权重，我们的目标很明确，就是要使得最后生成的树的所有权重之和最小。</p><p>比如，看下面这张图，我们现在想要使生成的树上所有边的权重和最小。</p><p><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE6.jpg"></p><p>根据贪心算法，我们<strong>显然希望用尽量短的边来连通树</strong>。所以Kruskal算法的原理非常简单，就是对这些边的权值进行排序，依次从短到长遍历这些边，然后通过并查集来查询正在遍历的这条边是否能够被添加，直到所有边都遍历结束。</p><h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><h3 id="1、完美图解"><a href="#1、完美图解" class="headerlink" title="1、完美图解"></a>1、完美图解</h3><p>下面图解出自陈小玉老师所主编的书《趣学算法》中，朋友们可以借助理解算法。<br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE7.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE8.jpg"><br><img src="/2020/11/11/zui-xiao-sheng-cheng-shu-kruskal-suan-fa/%E5%9B%BE9.jpg"></p><h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;#define VERTS 6  &#x2F;&#x2F;图的顶点数using namespace std;&#x2F;&#x2F;顶点的类class Edge&#123;public:    int from,to;  &#x2F;&#x2F;边依附的两个顶点    int find,weight;  &#x2F;&#x2F;边的权重    Edge *next;&#125;;int v[VERTS+1];Edge *findmincost(Edge *head);void mintree(Edge *head);int main()&#123;    &#x2F;&#x2F;各边状况    int data[10][3]&#x3D;&#123;&#123;1,2,6&#125;,&#123;1,6,12&#125;,&#123;1,5,10&#125;,                     &#123;2,3,3&#125;,&#123;2,4,5&#125;,&#123;2,6,8&#125;,                     &#123;3,4,7&#125;,&#123;4,6,11&#125;,&#123;4,5,9&#125;,&#123;5,6,16&#125;&#125;;    Edge *head,*newnode,*ptr;    &#x2F;&#x2F;建立图的链表    head&#x3D;NULL;    cout &lt;&lt; &quot;创建图的链表 ：&quot; &lt;&lt; endl;    for(int i&#x3D;1;i&lt;&#x3D;VERTS;i++)    &#123;        for(int j&#x3D;0;j&lt;10;j++)        &#123;            if(data[j][0]&#x3D;&#x3D;i)            &#123;                newnode&#x3D;new Edge;                newnode-&gt;from&#x3D;data[j][0];                newnode-&gt;to&#x3D;data[j][1];                newnode-&gt;weight&#x3D;data[j][2];                newnode-&gt;find&#x3D;0;                newnode-&gt;next&#x3D;NULL;                if(head&#x3D;&#x3D;NULL)  &#x2F;&#x2F;如果头结点为空，则创建新节点                &#123;                    head&#x3D;newnode;                    head-&gt;next&#x3D;NULL;                    ptr&#x3D;head;                &#125;                else                &#123;                    ptr-&gt;next&#x3D;newnode;                    ptr&#x3D;ptr-&gt;next;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F;打印图的链表    ptr&#x3D;head;    while(ptr!&#x3D;NULL)    &#123;        cout &lt;&lt; &quot;起始顶点 [&quot; &lt;&lt; ptr-&gt;from &lt;&lt; &quot;]&quot; &lt;&lt; setw(8)              &lt;&lt; &quot;终止顶点 [&quot; &lt;&lt; ptr-&gt;to &lt;&lt; &quot;]&quot;  &lt;&lt; setw(8)              &lt;&lt; &quot;路径长度 [&quot; &lt;&lt; ptr-&gt;weight &lt;&lt; &quot;]&quot; &lt;&lt; endl;        ptr&#x3D;ptr-&gt;next;  &#x2F;&#x2F;指针后移    &#125;    &#x2F;&#x2F;创建最小生成树    cout &lt;&lt; &quot;建立最小成本生成树：&quot; &lt;&lt; endl;    mintree(head);    delete newnode;    system(&quot;pause&quot;);    return 0;&#125;&#x2F;&#x2F;找到权值最小的边Edge *findmincost(Edge *head)&#123;    int minval&#x3D;100;  &#x2F;&#x2F;设置初始最小值    Edge *retptr,*ptr;    ptr&#x3D;head;    while(ptr!&#x3D;NULL)    &#123;        if(ptr-&gt;weight&lt;minval &amp;&amp; ptr-&gt;find&#x3D;&#x3D;0)        &#123;            &#x2F;&#x2F;假如ptr-&gt;val的值小于minval            minval&#x3D;ptr-&gt;weight;  &#x2F;&#x2F;将ptr-&gt;val设置最小值            retptr&#x3D;ptr;  &#x2F;&#x2F;并且记录ptr        &#125;        ptr&#x3D;ptr-&gt;next;    &#125;    retptr-&gt;find&#x3D;1;    return retptr;&#125;&#x2F;&#x2F;Kruscal算法实现最小生成树void mintree(Edge *head)&#123;    Edge *ptr,*mceptr;    int result&#x3D;0;  &#x2F;&#x2F;标识变量    &#x2F;&#x2F;初始化    for(int i&#x3D;0;i&lt;&#x3D;VERTS;i++)    &#123;        v[i]&#x3D;0;    &#125;    ptr&#x3D;head;    while(ptr!&#x3D;NULL)  &#x2F;&#x2F;画图比较形象    &#123;        mceptr&#x3D;findmincost(head);        v[mceptr-&gt;from]++;        v[mceptr-&gt;to]++;        if(v[mceptr-&gt;from]&gt;1 &amp;&amp; v[mceptr-&gt;to]&gt;1)        &#123;            v[mceptr-&gt;from]--;            v[mceptr-&gt;to]--;            result&#x3D;1;        &#125;        else        &#123;            result&#x3D;0;        &#125;        if(result&#x3D;&#x3D;0)        &#123;            cout &lt;&lt; &quot;起始顶点 [&quot; &lt;&lt; mceptr-&gt;from &lt;&lt; &quot;]&quot; &lt;&lt; setw(8)                  &lt;&lt; &quot;终止顶点 [&quot; &lt;&lt; mceptr-&gt;to &lt;&lt; &quot;]&quot;  &lt;&lt; setw(8)                  &lt;&lt; &quot;路径长度 [&quot; &lt;&lt; mceptr-&gt;weight &lt;&lt; &quot;]&quot; &lt;&lt; endl;        &#125;        ptr&#x3D;ptr-&gt;next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 树形结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
